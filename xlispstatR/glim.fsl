(XLISP::CHECK-FSL-VERSION 1 4)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #("glim" PROVIDE) 0 NIL)
#K(#(80 1 2 0 1 4 39 2 3 23 3 4 1 2 21 0 1 2 4 0 2 4 1 3 23 4 4 1 2 23 5 3 2 3 4 0 2 4 16 4 5 21 1 4 5 4 38 6 6 23 7 0 3 3 6 5 17 4 4 16 4 5 21 1 4 5 4 38 8 6 23 7 0 4 3 6 1 2 23 9 0 2 1 3 11 0 1) #(0 19 24 29 46 67) #(GLIM-LINK-PROTO NIL MAKE-OBJECT LISTP LIST APPLY :ADD-SLOT SEND :MAKE-PROTOTYPE SET) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Method args: (mu)
Returns linear predictor values at MU." :ETA #K(#(80 3 0 0 11 0 2) #(0) #() 0 NIL) GLIM-LINK-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:ETA) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Method args: (eta)
Returns mean values for linear predictor ETA." :MEANS #K(#(80 3 0 0 11 0 2) #(0) #() 0 NIL) GLIM-LINK-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:MEANS) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Method args: (mu)
Returns d(eta)/d(mu) values at MU." :DERIVS #K(#(80 3 1 0 1 23 1 4 1 2 25 2 0 2 3 4) #(0) #(1 LENGTH REPEAT) 0 NIL) GLIM-LINK-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:DERIVS) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :PRINT #K(#(77 1 2 1 2 2 0 1 1 62 4 5 25 3 0 3 2 3 5) #(0) #("#<Glim Link Object: ~s>" PROTO-NAME #(T) FORMAT) 0 NIL) GLIM-LINK-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:PRINT) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :SAVE #K(#(80 2 3 0 1 2 4 62 4 5 23 3 6 1 5 50 0 1 2 1 6 11 0 5 23 4 6 1 3 23 4 7 1 5 23 4 8 1 2 25 5 0 3 6 7 8) #(0 21 24) #(:NEW SEND PROTO-NAME EVAL LIST APPEND) 0 NIL) GLIM-LINK-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:SAVE) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 2 0 1 4 38 2 3 39 3 4 23 4 5 1 3 21 0 1 2 5 0 3 5 1 3 23 5 5 1 3 23 6 3 2 4 5 0 2 4 16 4 5 21 1 4 5 4 38 7 6 23 8 0 3 3 6 5 17 4 4 16 4 5 21 1 4 5 4 38 9 6 23 8 0 4 3 6 1 2 23 10 0 2 1 3 11 0 1) #(0 22 27 32 49 70) #(IDENTITY-LINK NIL GLIM-LINK-PROTO MAKE-OBJECT LISTP LIST APPLY :ADD-SLOT SEND :MAKE-PROTOTYPE SET) 0 NIL)
#K(#(80 1 2 0 1 4 38 2 3 39 3 4 23 4 5 1 3 21 0 1 2 5 0 3 5 1 3 23 5 5 1 3 23 6 3 2 4 5 0 2 4 16 4 5 21 1 4 5 4 38 7 6 23 8 0 3 3 6 5 17 4 4 16 4 5 21 1 4 5 4 38 9 6 23 8 0 4 3 6 1 2 23 10 0 2 1 3 11 0 1) #(0 22 27 32 49 70) #(LOG-LINK NIL GLIM-LINK-PROTO MAKE-OBJECT LISTP LIST APPLY :ADD-SLOT SEND :MAKE-PROTOTYPE SET) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :ETA #K(#(80 3 0 0 25 0 0 1 2) #(0) #(LOG) 0 NIL) LOG-LINK BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:ETA) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :MEANS #K(#(80 3 0 0 25 0 0 1 2) #(0) #(EXP) 0 NIL) LOG-LINK BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:MEANS) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :DERIVS #K(#(80 3 0 0 61 47 2 0 57 0) #(0) #() 0 NIL) LOG-LINK BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:DERIVS) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 2 0 1 4 38 2 3 39 3 4 23 4 5 1 3 21 0 1 2 5 0 3 5 1 3 23 5 5 1 3 23 6 3 2 4 5 0 2 4 16 4 5 21 1 4 5 4 38 7 6 23 8 0 3 3 6 5 17 4 4 16 4 5 21 1 4 5 4 38 9 6 23 8 0 4 3 6 1 2 23 10 0 2 1 3 11 0 1) #(0 22 27 32 49 70) #(INVERSE-LINK NIL GLIM-LINK-PROTO MAKE-OBJECT LISTP LIST APPLY :ADD-SLOT SEND :MAKE-PROTOTYPE SET) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :ETA #K(#(80 3 0 0 61 47 2 0 57 0) #(0) #() 0 NIL) INVERSE-LINK BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:ETA) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :MEANS #K(#(80 3 0 0 61 47 2 0 57 0) #(0) #() 0 NIL) INVERSE-LINK BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:MEANS) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :DERIVS #K(#(80 3 1 0 1 23 1 4 2 2 3 61 47 4 4 61 45 4 0 57 0) #(0) #(2 ^) 0 NIL) INVERSE-LINK BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:DERIVS) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 2 0 1 4 38 2 3 39 3 4 23 4 5 1 3 21 0 1 2 5 0 3 5 1 3 23 5 5 1 3 23 6 3 2 4 5 0 2 4 16 4 5 21 1 4 5 4 38 7 6 23 8 0 3 3 6 5 17 4 4 16 4 5 21 1 4 5 4 38 9 6 23 8 0 4 3 6 1 2 23 10 0 2 1 3 11 0 1) #(0 22 27 32 49 70) #(SQRT-LINK NIL GLIM-LINK-PROTO MAKE-OBJECT LISTP LIST APPLY :ADD-SLOT SEND :MAKE-PROTOTYPE SET) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :ETA #K(#(80 3 0 0 25 0 0 1 2) #(0) #(SQRT) 0 NIL) SQRT-LINK BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:ETA) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :MEANS #K(#(80 3 1 0 0 25 1 0 2 2 3) #(0) #(2 ^) 0 NIL) SQRT-LINK BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:MEANS) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :DERIVS #K(#(80 3 1 0 1 23 1 4 1 2 2 47 3 4 0 57 0) #(0) #(0.5 SQRT) 0 NIL) SQRT-LINK BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:DERIVS) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 3 0 1 2 4 38 3 4 39 4 5 23 5 6 1 4 21 0 1 2 6 0 4 6 1 3 23 6 6 1 4 23 7 4 2 5 6 0 3 5 16 5 6 21 1 4 5 5 38 8 7 23 9 0 3 4 7 6 17 5 5 16 5 6 21 1 4 5 5 38 10 7 23 9 0 4 4 7 2 1 23 11 0 2 2 4 11 0 2) #(0 23 28 33 50 71) #((POWER) POWER-LINK-PROTO NIL GLIM-LINK-PROTO MAKE-OBJECT LISTP LIST APPLY :ADD-SLOT SEND :MAKE-PROTOTYPE SET) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :ISNEW #K(#(80 3 1 0 0 63 3 2 0 57 0) #(0) #(POWER) 0 NIL) POWER-LINK-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:ISNEW) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :POWER #K(#(80 2 1 0 0 62 2 0 57 0) #(0) #(POWER) 0 NIL) POWER-LINK-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:POWER) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :PRINT #K(#(77 1 2 1 1 1 0 1 38 2 4 23 3 4 2 1 4 25 4 0 3 2 3 4) #(0) #("#<Glim Link Object: Power Link (~s)>" #(T) :POWER SEND FORMAT) 0 NIL) POWER-LINK-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:PRINT) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :SAVE #K(#(80 2 3 0 1 2 4 23 3 5 1 4 23 3 6 1 3 23 3 7 1 2 38 4 8 23 2 8 2 1 8 23 3 8 1 8 25 5 0 4 5 6 7 8) #(0) #(:NEW POWER-LINK-PROTO SEND LIST :POWER APPEND) 0 NIL) POWER-LINK-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:SAVE) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :ETA #K(#(80 3 0 1 38 0 3 23 1 3 2 1 3 25 2 0 2 2 3) #(0) #(:POWER SEND ^) 0 NIL) POWER-LINK-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:ETA) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :MEANS #K(#(80 3 1 0 1 62 3 4 61 47 4 4 25 1 0 2 2 4) #(0) #(POWER ^) 0 NIL) POWER-LINK-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:MEANS) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :DERIVS #K(#(80 3 2 0 1 2 62 4 5 2 45 5 3 6 23 2 6 2 2 6 2 42 5 6 0 57 0) #(0) #(1 POWER ^) 0 NIL) POWER-LINK-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:DERIVS) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 2 0 1 4 38 2 3 39 3 4 23 4 5 1 3 21 0 1 2 5 0 3 5 1 3 23 5 5 1 3 23 6 3 2 4 5 0 2 4 16 4 5 21 1 4 5 4 38 7 6 23 8 0 3 3 6 5 17 4 4 16 4 5 21 1 4 5 4 38 9 6 23 8 0 4 3 6 1 2 23 10 0 2 1 3 11 0 1) #(0 22 27 32 49 70) #(LOGIT-LINK NIL GLIM-LINK-PROTO MAKE-OBJECT LISTP LIST APPLY :ADD-SLOT SEND :MAKE-PROTOTYPE SET) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :ETA #K(#(80 3 1 0 1 2 45 3 2 4 2 47 2 4 4 25 1 0 1 4) #(0) #(1 LOG) 0 NIL) LOGIT-LINK BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:ETA) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :MEANS #K(#(80 3 1 0 2 23 1 4 1 2 2 43 3 4 5 2 47 4 5 0 57 0) #(0) #(1 EXP) 0 NIL) LOGIT-LINK BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:MEANS) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :DERIVS #K(#(80 3 1 0 2 61 47 2 4 2 45 3 2 5 61 47 5 5 2 43 4 5 0 57 0) #(0) #(1) 0 NIL) LOGIT-LINK BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:DERIVS) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 2 0 1 4 38 2 3 39 3 4 23 4 5 1 3 21 0 1 2 5 0 3 5 1 3 23 5 5 1 3 23 6 3 2 4 5 0 2 4 16 4 5 21 1 4 5 4 38 7 6 23 8 0 3 3 6 5 17 4 4 16 4 5 21 1 4 5 4 38 9 6 23 8 0 4 3 6 1 2 23 10 0 2 1 3 11 0 1) #(0 22 27 32 49 70) #(PROBIT-LINK NIL GLIM-LINK-PROTO MAKE-OBJECT LISTP LIST APPLY :ADD-SLOT SEND :MAKE-PROTOTYPE SET) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :ETA #K(#(80 3 0 0 25 0 0 1 2) #(0) #(NORMAL-QUANT) 0 NIL) PROBIT-LINK BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:ETA) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :MEANS #K(#(80 3 0 0 25 0 0 1 2) #(0) #(NORMAL-CDF) 0 NIL) PROBIT-LINK BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:MEANS) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :DERIVS #K(#(80 3 1 0 1 23 1 4 1 2 23 2 4 1 4 2 47 3 4 0 57 0) #(0) #(1 NORMAL-QUANT NORMAL-DENS) 0 NIL) PROBIT-LINK BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:DERIVS) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 2 0 1 4 38 2 3 39 3 4 23 4 5 1 3 21 0 1 2 5 0 3 5 1 3 23 5 5 1 3 23 6 3 2 4 5 0 2 4 16 4 5 21 1 4 5 4 38 7 6 23 8 0 3 3 6 5 17 4 4 16 4 5 21 1 4 5 4 38 9 6 23 8 0 4 3 6 1 2 23 10 0 2 1 3 11 0 1) #(0 22 27 32 49 70) #(CLOGLOG-LINK NIL GLIM-LINK-PROTO MAKE-OBJECT LISTP LIST APPLY :ADD-SLOT SEND :MAKE-PROTOTYPE SET) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :ETA #K(#(80 3 1 0 1 2 45 3 2 4 23 1 4 1 4 61 45 4 4 25 1 0 1 4) #(0) #(1 LOG) 0 NIL) CLOGLOG-LINK BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:ETA) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :MEANS #K(#(80 3 1 0 1 23 1 4 1 2 61 45 4 4 23 1 4 1 4 2 45 3 4 0 57 0) #(0) #(1 EXP) 0 NIL) CLOGLOG-LINK BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:MEANS) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :DERIVS #K(#(80 3 2 0 1 2 2 45 4 2 5 23 2 6 1 5 25 3 0 3 3 6 5) #(0) #(-1 1 LOG /) 0 NIL) CLOGLOG-LINK BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:DERIVS) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 3 0 1 2 4 38 3 4 39 4 5 23 5 6 1 4 21 0 1 2 6 0 4 6 1 3 23 6 6 1 4 23 7 4 2 5 6 0 3 5 16 5 6 21 1 4 5 5 38 8 7 23 9 0 3 4 7 6 17 5 5 16 5 6 21 1 4 5 5 38 10 7 23 9 0 4 4 7 2 1 23 11 0 2 2 4 11 0 2) #(0 23 28 33 50 71) #((YVAR LINK OFFSET PWEIGHTS SCALE EST-SCALE EPSILON EPSILON-DEV COUNT-LIMIT VERBOSE RECYCLE ETA DEVIANCES) GLIM-PROTO NIL REGRESSION-MODEL-PROTO MAKE-OBJECT LISTP LIST APPLY :ADD-SLOT SEND :MAKE-PROTOTYPE SET) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Message args: (&optional new)
Sets or returns dependent variable." :YVAR #K(#(77 1 2 1 3 3 0 1 2 3 64 2 6 21 2 1 2 2 0 2 7 1 3 0 4 7 21 0 4 5 6 63 5 7 0 38 4 8 23 5 0 3 1 8 3 62 5 0 57 0) #(0 18 23 26 31 45) #(T NIL YVAR #(%NOT-SUPPLIED) :NEEDS-COMPUTING SEND) 0 NIL) GLIM-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:YVAR) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Message args: (&optional new)
Sets or returns link object." :LINK #K(#(77 1 2 1 3 3 0 1 2 3 64 2 6 21 2 1 2 2 0 2 7 1 3 0 4 7 21 0 4 5 6 63 5 7 0 38 4 8 23 5 0 3 1 8 3 62 5 0 57 0) #(0 18 23 26 31 45) #(T NIL LINK #(%NOT-SUPPLIED) :NEEDS-COMPUTING SEND) 0 NIL) GLIM-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:LINK) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Message args: (&optional (new nil set))
Sets or returns offset values." :OFFSET #K(#(77 1 2 1 3 3 0 1 2 3 64 2 6 21 2 1 2 2 0 2 7 1 3 0 4 7 21 0 4 5 6 63 5 7 0 38 4 8 23 5 0 3 1 8 3 62 5 0 57 0) #(0 18 23 26 31 45) #(T NIL OFFSET #(%NOT-SUPPLIED) :NEEDS-COMPUTING SEND) 0 NIL) GLIM-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:OFFSET) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Message args: (&optional (new nil set))
Sets or returns prior weights." :PWEIGHTS #K(#(77 1 2 1 3 3 0 1 2 3 64 2 6 21 2 1 2 2 0 2 7 1 3 0 4 7 21 0 4 5 6 63 5 7 0 38 4 8 23 5 0 3 1 8 3 62 5 0 57 0) #(0 18 23 26 31 45) #(T NIL PWEIGHTS #(%NOT-SUPPLIED) :NEEDS-COMPUTING SEND) 0 NIL) GLIM-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:PWEIGHTS) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Message args: (&optional (new nil set))
Sets or returns value of scale parameter." :SCALE #K(#(77 1 2 1 2 2 0 1 2 64 2 5 21 2 1 2 2 0 2 6 1 3 0 3 6 21 0 4 5 5 63 4 6 0 62 4 0 57 0) #(0 17 22 25 30 34) #(NIL SCALE #(%NOT-SUPPLIED)) 0 NIL) GLIM-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:SCALE) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Message args: (&optional (val nil set))
Sets or returns value of ESTIMATE-SCALE option." :ESTIMATE-SCALE #K(#(77 1 2 1 2 2 0 1 2 64 2 5 21 2 1 2 2 0 2 6 1 3 0 3 6 21 0 4 5 5 63 4 6 0 62 4 0 57 0) #(0 17 22 25 30 34) #(NIL EST-SCALE #(%NOT-SUPPLIED)) 0 NIL) GLIM-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:ESTIMATE-SCALE) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Message args: (&optional new)
Sets or returns tolerance for relative change in coefficients." :EPSILON #K(#(77 1 2 1 2 2 0 1 0 21 0 1 2 2 63 4 2 0 62 4 0 57 0) #(0 14 18) #(NIL EPSILON #(NIL)) 0 NIL) GLIM-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:EPSILON) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Message args: (&optional new)
Sets or returns tolerance for change in deviance." :EPSILON-DEV #K(#(77 1 2 1 2 2 0 1 0 21 0 1 2 2 63 4 2 0 62 4 0 57 0) #(0 14 18) #(NIL EPSILON-DEV #(NIL)) 0 NIL) GLIM-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:EPSILON-DEV) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Message args: (&optional new)
Sets or returns maximum number of itrations." :COUNT-LIMIT #K(#(77 1 2 1 2 2 0 1 0 21 0 1 2 2 63 4 2 0 62 4 0 57 0) #(0 14 18) #(NIL COUNT-LIMIT #(NIL)) 0 NIL) GLIM-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:COUNT-LIMIT) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Message args: (&optional new)
Sets or returns recycle option. If option is not NIL, current values
are used as initial values by :COMPUTE method." :RECYCLE #K(#(77 1 2 1 2 2 0 1 2 64 2 5 21 2 1 2 2 0 2 6 1 3 0 3 6 21 0 4 5 5 63 4 6 0 62 4 0 57 0) #(0 17 22 25 30 34) #(NIL RECYCLE #(%NOT-SUPPLIED)) 0 NIL) GLIM-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:RECYCLE) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Message args: (&optional (val nil set))
Sets or returns VERBOSE option. Iteration info is printed if option
is not NIL." :VERBOSE #K(#(77 1 2 1 2 2 0 1 2 64 2 5 21 2 1 2 2 0 2 6 1 3 0 3 6 21 0 4 5 5 63 4 6 0 62 4 0 57 0) #(0 17 22 25 30 34) #(NIL VERBOSE #(%NOT-SUPPLIED)) 0 NIL) GLIM-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:VERBOSE) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Message args: ()
Returns linear predictor values for durrent fit." :ETA #K(#(80 2 1 0 0 62 2 0 57 0) #(0) #(ETA) 0 NIL) GLIM-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:ETA) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :SET-ETA #K(#(77 1 2 1 1 1 0 2 21 0 1 2 2 63 3 2 0 57 0 38 2 4 23 3 4 2 1 4 38 4 5 23 3 5 2 1 5 2 43 4 5 4 63 3 4 0 57 0) #(0 13 19) #(ETA #(NIL) :OFFSET SEND :FIT-VALUES) 0 NIL) GLIM-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:SET-ETA) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Message args: ()
Returns deviances for durrent fit." :DEVIANCES #K(#(80 2 1 0 0 62 2 0 57 0) #(0) #(DEVIANCES) 0 NIL) GLIM-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:DEVIANCES) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :SET-DEVIANCES #K(#(80 2 1 0 2 38 1 3 38 2 4 23 3 4 2 1 4 23 3 3 3 1 3 4 63 2 3 0 57 0) #(0) #(DEVIANCES :FIT-DEVIANCES :FIT-MEANS SEND) 0 NIL) GLIM-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:SET-DEVIANCES) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :SAVE #K(#(80 2 16 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 13 62 17 18 38 16 19 23 3 19 2 1 19 23 17 19 2 16 19 39 18 20 23 1 20 2 20 19 23 19 21 1 15 23 19 22 1 14 23 19 23 1 13 23 19 24 1 18 23 20 23 2 23 24 23 19 23 1 23 23 20 22 2 22 23 23 19 22 1 22 23 19 23 1 12 23 19 24 1 11 23 19 25 1 19 23 20 24 2 24 25 23 19 24 1 24 23 20 23 2 23 24 23 19 23 1 23 23 19 24 1 10 23 19 25 1 11 23 19 26 1 20 23 20 25 2 25 26 23 19 25 1 25 23 20 24 2 24 25 23 19 24 1 24 23 20 22 3 22 23 24 23 19 22 1 22 23 19 23 1 9 23 19 24 1 8 23 19 25 1 7 23 19 26 1 6 23 20 25 2 25 26 23 19 25 1 25 23 19 26 1 5 23 19 27 1 14 23 19 28 1 4 23 19 29 1 7 23 19 30 1 6 23 20 26 5 26 27 28 29 30 23 19 26 1 26 23 20 24 3 24 25 26 23 19 24 1 24 23 20 24 1 24 23 19 24 1 24 23 19 25 1 3 23 19 26 1 2 23 19 27 1 8 23 20 26 2 26 27 23 19 26 1 26 23 19 27 1 12 23 19 28 1 10 23 20 25 4 25 26 27 28 23 19 25 1 25 23 19 26 1 8 23 19 27 1 11 23 19 28 1 16 23 20 27 2 27 28 23 19 27 1 27 38 21 28 23 3 28 2 1 28 38 22 29 23 3 28 2 28 29 23 19 28 1 28 23 20 26 3 26 27 28 23 19 26 1 26 23 20 23 4 23 24 25 26 23 19 23 1 23 23 19 24 1 14 25 20 0 4 21 22 23 24) #(0) #(FUNCTION MAPCAR :ADD-SLOT SEND V S ADD-SLOT FLET VALUES QUOTE SLOTS MAKE-OBJECT OBJECT LET LINK PROTO-NAME :OWN-SLOTS REMOVE SLOT-VALUE LIST APPEND :LINK :SAVE) 0 NIL) GLIM-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:SAVE) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :SIGMA-HAT #K(#(80 2 0 1 38 0 2 23 1 2 2 1 2 25 2 0 1 2) #(0) #(:SCALE SEND SQRT) 0 NIL) GLIM-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:SIGMA-HAT) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Message args: ()
Returns Xb, the linear predictor values without the offset.
The :fit-means method returns fitted means for the current estimates." :FIT-VALUES #K(#(80 2 0 0 25 0 0 0) #(0) #(CALL-NEXT-METHOD) 0 NIL) GLIM-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:FIT-VALUES) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :X #K(#(77 1 2 1 1 1 0 3 21 0 1 14 2 23 2 4 1 2 21 0 2 3 4 0 2 4 1 11 23 3 5 1 2 21 0 4 5 5 23 4 4 1 2 1 11 21 1 6 7 2 16 2 5 23 5 5 1 5 1 8 0 3 5 21 0 9 10 5 23 4 4 1 2 1 11 0 2 4 23 2 5 1 4 21 0 13 12 5 39 6 6 23 7 4 2 6 4 23 8 0 1 4 25 8 0 0) #(0 13 23 28 38 45 50 60 63 68 75 78 88 97 102) #(NIL #(NIL) MATRIXP VECTORP LIST NUMBERP BIND-COLUMNS APPLY CALL-NEXT-METHOD) 0 NIL) GLIM-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:X) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Message args: ()
Returns the raw residuals for a model." :RAW-RESIDUALS #K(#(80 2 0 2 38 0 2 23 1 2 2 1 2 38 2 3 23 1 3 2 1 3 2 45 2 3 0 57 0) #(0) #(:YVAR SEND :FIT-MEANS) 0 NIL) GLIM-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:RAW-RESIDUALS) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Message args: ()
Returns the Pearson residuals." :RESIDUALS #K(#(80 2 0 2 38 0 2 23 1 2 2 1 2 38 2 3 23 1 3 2 1 3 2 45 2 3 2 38 3 3 23 1 3 2 1 3 21 0 1 2 3 23 4 3 1 3 2 42 3 2 0 57 0 11 0 2) #(0 41 53) #(:Y SEND :FIT-VALUES :WEIGHTS SQRT) 0 NIL) REGRESSION-MODEL-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:RESIDUALS) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :COMPUTE #K(#(80 2 7 0 1 2 3 4 5 6 15 38 7 9 23 8 9 2 1 9 38 9 10 23 8 10 2 1 10 38 10 11 23 8 11 2 1 11 38 11 12 2 47 12 9 12 2 42 8 12 12 38 12 13 23 8 13 2 1 13 38 13 14 23 8 14 2 1 14 21 0 1 2 14 38 14 15 23 8 14 2 1 15 1 3 0 4 14 21 0 5 4 14 38 15 15 23 8 0 2 1 15 38 16 14 23 8 0 2 1 14 0 7 14 0 6 15 0 5 16 0 6 17 0 5 18 3 62 14 11 19 21 0 9 6 19 2 45 15 16 20 23 17 21 1 16 23 18 21 2 21 12 2 47 20 21 20 23 17 20 1 20 23 19 20 1 20 3 60 20 9 20 21 0 7 8 20 0 20 19 1 9 2 45 17 18 20 23 17 20 1 20 3 60 20 10 19 21 0 17 10 19 21 0 11 12 13 38 20 19 23 8 19 2 1 19 23 21 0 4 3 2 14 19 38 16 19 23 8 0 2 1 19 2 43 14 7 19 38 22 20 23 8 20 2 1 20 0 15 21 38 20 22 23 8 22 2 1 22 0 17 23 0 19 14 0 20 15 0 21 16 0 22 17 0 23 18 3 62 14 11 19 21 0 16 13 19 2 45 15 16 20 23 17 21 1 16 23 18 21 2 21 12 2 47 20 21 20 23 17 20 1 20 23 19 20 1 20 3 60 20 9 20 21 0 14 15 20 0 20 19 1 16 2 45 17 18 20 23 17 20 1 20 3 60 20 10 19 21 0 17 10 19 11 0 4) #(0 74 85 88 93 102 136 177 182 197 202 207 224 287 328 333 348 353) #("Iteration ~d: deviance = ~,6g~%" T NIL -1 0 1 2 :EPSILON SEND :EPSILON-DEV :COUNT-LIMIT MACHINE-EPSILON :VERBOSE :ETA :RECYCLE :INITIALIZE-SEARCH :COMPUTE-STEP ABS PMAX MAX :DEVIANCE FORMAT :COEF-ESTIMATES) 0 NIL) GLIM-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:COMPUTE) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Args: ()
Executes one iteratively reweighted least squares step." :COMPUTE-STEP #K(#(80 2 1 0 10 38 1 3 23 2 3 2 1 3 38 3 4 23 2 4 2 1 4 38 4 5 23 2 5 2 1 5 38 5 6 23 2 6 3 1 6 5 38 6 7 23 2 7 3 1 7 6 2 45 3 6 8 2 42 8 7 8 2 43 5 8 8 2 45 8 4 8 38 7 9 23 2 9 3 1 9 6 23 8 9 3 7 7 9 38 9 10 23 2 10 2 1 10 38 10 11 23 2 0 3 1 11 8 38 11 11 21 0 1 2 10 2 47 10 9 12 1 3 61 47 9 12 23 2 0 3 1 11 12 38 12 3 38 13 4 23 14 0 2 3 4 38 15 3 23 2 0 2 1 3 38 16 3 23 2 0 2 1 3 38 17 3 23 2 3 2 1 3 21 0 4 5 3 38 18 3 38 19 4 23 2 4 2 1 4 25 2 0 3 1 3 4 11 0 2) #(0 116 123 127 178 197) #(NIL :YVAR SEND :OFFSET :ETA :FIT-MEANS :FIT-LINK-DERIVS :FIT-VARIANCES * :PWEIGHTS :Y :WEIGHTS REGRESSION-MODEL-PROTO :COMPUTE CALL-METHOD :SET-ETA :SET-DEVIANCES :ESTIMATE-SCALE :SCALE :FIT-SCALE) 0 NIL) GLIM-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:COMPUTE-STEP) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Message args: ()
Returns deviance for included cases." :DEVIANCE #K(#(80 2 1 0 2 38 1 3 23 2 3 2 1 3 38 3 4 23 2 4 2 1 4 23 4 3 3 3 4 2 25 5 0 1 3) #(0) #(0 :INCLUDED SEND :DEVIANCES IF-ELSE SUM) 0 NIL) GLIM-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:DEVIANCE) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Message args: ()
Returns mean deviance for included cases, adjusted for degrees of
freedom." :MEAN-DEVIANCE #K(#(80 2 0 2 38 0 2 23 1 2 2 1 2 38 2 3 23 1 3 2 1 3 2 47 2 3 0 57 0) #(0) #(:DEVIANCE SEND :DF) 0 NIL) GLIM-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:MEAN-DEVIANCE) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :INITIALIZE-SEARCH #K(#(77 1 2 1 1 1 0 4 38 2 4 21 0 1 2 2 0 2 5 1 3 38 3 5 23 4 5 2 1 5 38 5 6 38 6 7 23 4 7 2 1 7 23 4 5 3 5 6 7 23 4 0 3 1 4 5 38 7 4 25 4 0 3 1 4 3) #(0 16 21 49) #(T #(NIL) :SET-ETA :LINK SEND :ETA :INITIAL-MEANS :NEEDS-COMPUTING) 0 NIL) GLIM-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:INITIALIZE-SEARCH) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Message args: (&optional (eta (send self :eta)))
Retruns mean values for current or supplied ETA." :FIT-MEANS #K(#(77 1 2 1 0 0 3 21 2 1 2 2 0 2 3 1 3 38 1 3 23 2 3 2 1 3 38 3 4 23 2 4 2 1 4 38 4 5 25 2 0 3 4 5 3) #(0 12 17 26) #(#(%NOT-SUPPLIED) :ETA SEND :LINK :MEANS) 0 NIL) GLIM-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:FIT-MEANS) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Message args: ()
Returns link derivative values at MU." :FIT-LINK-DERIVS #K(#(80 3 0 2 38 0 3 23 1 3 2 1 3 38 2 4 25 1 0 3 3 4 2) #(0) #(:LINK SEND :DERIVS) 0 NIL) GLIM-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:FIT-LINK-DERIVS) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Message args: ()
Prints the IRWLS regression summary. Variables not used in the fit are
marked as aliased." :DISPLAY #K(#(80 2 17 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 12 38 17 19 23 18 19 2 1 19 23 19 19 2 19 18 38 20 20 23 18 20 2 1 20 38 21 21 23 18 21 2 1 21 38 22 22 23 18 22 2 1 22 0 19 23 0 20 24 38 23 25 23 18 25 2 1 25 21 0 1 2 25 23 24 0 2 15 2 1 3 23 24 0 2 15 3 38 25 25 23 18 25 2 1 25 21 0 4 5 25 16 23 26 16 24 27 23 24 0 4 15 4 26 27 17 23 23 17 24 24 23 26 25 2 21 17 0 16 26 37 60 6 10 26 25 38 27 27 23 18 27 2 1 27 23 28 27 2 26 27 21 0 7 8 27 23 29 28 2 22 26 16 23 29 16 24 30 23 24 0 5 15 5 28 29 30 17 23 23 17 24 24 1 9 23 29 28 2 22 26 23 24 0 3 15 6 28 61 112 26 26 37 60 6 10 26 25 23 24 0 2 15 14 38 30 27 23 18 27 2 1 27 21 0 11 12 27 38 31 28 23 18 28 2 1 28 23 24 0 3 15 7 28 1 13 38 31 28 23 18 28 2 1 28 23 24 0 3 15 8 28 38 32 27 23 18 27 2 1 27 23 24 0 3 15 13 27 38 33 27 23 18 27 2 1 27 23 24 0 3 15 12 27 38 33 27 23 18 27 2 1 27 38 34 28 23 18 28 2 1 28 37 35 14 15 27 28 38 34 29 23 18 29 2 1 29 23 24 0 3 15 9 29 38 35 27 23 18 27 2 1 27 23 24 0 3 15 11 27 25 24 0 2 15 14) #(0 83 91 97 111 131 146 166 195 208 218 238 256 272 328 344) #("~%Weighted Least Squares Estimates:~2%" "~%Least Squares Estimates:~2%" "Constant~25t~13,6g~40t(~,6g)~%" "~a~25t~13,6g~40t(~,6g)~%" "~a~25taliased~%" "Scale Estimate:~25t~13,6g~%" "Scale taken as:~25t~13,6g~%" "Number of cases used:~25t~9d~%" NIL "Degrees of freedom:~25t~9d~%" "Number of cases:~25t~9d~%" "Deviance:~25t~13,6g~%" "~%" T 0 1 LIST :COEF-ESTIMATES SEND COERCE :COEF-STANDARD-ERRORS :X :PREDICTOR-NAMES :WEIGHTS FORMAT :INTERCEPT ARRAY-DIMENSION :BASIS MEMBER SELECT :ESTIMATE-SCALE :SCALE :DEVIANCE :NUM-CASES :NUM-INCLUDED :DF) 0 NIL) GLIM-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:DISPLAY) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Message args: ()
Returns initial means estimate for starting the iteration." :INITIAL-MEANS #K(#(80 2 0 1 38 0 2 25 1 0 2 1 2) #(0) #(:YVAR SEND) 0 NIL) GLIM-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:INITIAL-MEANS) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Message args: (mu)
Returns variance function values at MU." :FIT-VARIANCES #K(#(80 3 1 0 1 23 1 4 1 2 25 2 0 2 3 4) #(0) #(1 LENGTH REPEAT) 0 NIL) GLIM-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:FIT-VARIANCES) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Message args: (mu)
Returns deviance values at MU." :FIT-DEVIANCES #K(#(80 3 1 0 2 38 1 4 23 2 4 2 1 4 2 45 4 2 4 23 3 4 2 4 3 38 4 5 23 2 5 2 1 5 21 0 1 2 5 2 42 5 4 0 57 0 11 0 4) #(0 39 46) #(2 :YVAR SEND ^ :PWEIGHTS) 0 NIL) GLIM-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:FIT-DEVIANCES) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Message args: ()
Returns estimate of scale parameter." :FIT-SCALE #K(#(80 2 0 1 38 0 2 25 1 0 2 1 2) #(0) #(:MEAN-DEVIANCE SEND) 0 NIL) GLIM-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:FIT-SCALE) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 2 38 1 2 38 2 3 25 3 0 3 2 3 1) #(0) #(1.0 GLIM-PROTO :SCALE SEND) 0 NIL)
#K(#(80 1 1 0 2 38 1 2 38 2 3 25 3 0 3 2 3 1) #(0) #(0.0 GLIM-PROTO :OFFSET SEND) 0 NIL)
#K(#(80 1 0 3 38 0 1 38 1 2 38 2 3 25 3 0 3 1 2 3) #(0) #(GLIM-PROTO :LINK IDENTITY-LINK SEND) 0 NIL)
#K(#(80 1 1 0 2 38 1 2 38 2 3 25 3 0 3 2 3 1) #(0) #(T GLIM-PROTO :ESTIMATE-SCALE SEND) 0 NIL)
#K(#(80 1 1 0 2 38 1 2 38 2 3 25 3 0 3 2 3 1) #(0) #(1.0E-6 GLIM-PROTO :EPSILON SEND) 0 NIL)
#K(#(80 1 1 0 2 38 1 2 38 2 3 25 3 0 3 2 3 1) #(0) #(0.001 GLIM-PROTO :EPSILON-DEV SEND) 0 NIL)
#K(#(80 1 1 0 2 38 1 2 38 2 3 25 3 0 3 2 3 1) #(0) #(30 GLIM-PROTO :COUNT-LIMIT SEND) 0 NIL)
#K(#(80 1 1 0 2 38 1 2 38 2 3 25 3 0 3 2 3 1) #(0) #(T GLIM-PROTO :VERBOSE SEND) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :ISNEW #K(#(77 3 2 0 0 0 2 1 1 0 2 21 2 1 2 9 0 9 16 1 5 21 0 3 4 2 0 3 16 1 5 0 15 16 38 3 17 23 4 0 3 1 17 2 38 5 17 23 4 0 3 1 17 3 38 6 17 23 4 0 3 1 17 3 21 0 6 7 4 38 7 17 23 4 0 3 1 17 4 38 8 17 23 4 0 3 1 17 5 38 9 17 23 4 0 3 1 17 6 38 10 17 23 4 0 3 1 17 8 38 11 17 23 4 0 3 1 17 13 38 12 17 23 4 0 3 1 17 10 21 0 8 9 7 38 13 17 23 4 0 3 1 17 7 21 0 10 11 11 38 14 17 23 4 0 3 1 17 11 21 0 12 13 12 38 15 17 23 4 0 3 1 17 12 21 0 15 14 3 21 0 15 16 14 38 16 17 23 4 0 3 1 17 14 21 0 17 18 16 38 17 16 25 4 0 2 1 16 11 0 15) #(0 16 21 26 31 34 69 79 134 144 149 159 164 174 179 184 194 199 208) #(NIL (NIL NIL NIL 0 T NIL NIL %NOT-SUPPLIED T NIL NIL NIL NIL) (:X :Y :LINK :OFFSET :INTERCEPT :INCLUDED :PWEIGHTS :PRINT :VERBOSE :PREDICTOR-NAMES :RESPONSE-NAME :RECYCLE :CASE-LABELS) :X SEND :Y :YVAR :LINK :OFFSET :INTERCEPT :PWEIGHTS :RECYCLE :VERBOSE :INCLUDED :PREDICTOR-NAMES :RESPONSE-NAME :CASE-LABELS :DISPLAY) 0 NIL) GLIM-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:ISNEW) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Message args: ()
Returns the components of Pearson's chi-squared residuals." :CHI-RESIDUALS #K(#(80 2 0 1 38 0 2 25 1 0 2 1 2) #(0) #(:RESIDUALS SEND) 0 NIL) GLIM-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:CHI-RESIDUALS) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Message args: ()
Returns the components of Standardized Pearson Residuals (Williams, 1987)." :STANDARDIZED-CHI-RESIDUALS #K(#(80 2 0 1 38 0 2 25 1 0 2 1 2) #(0) #(:STUDENTIZED-RESIDUALS SEND) 0 NIL) GLIM-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:STANDARDIZED-CHI-RESIDUALS) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Message args: ()
Returns the components of deviance residuals for non binomial models." :DEVIANCE-RESIDUALS #K(#(80 2 2 0 1 3 38 2 4 23 3 4 2 1 4 23 4 4 1 4 38 5 5 23 3 5 2 1 5 38 6 6 23 3 6 2 1 6 3 60 5 6 5 23 7 5 3 5 3 2 2 42 5 4 0 57 0) #(0) #(1 -1 :DEVIANCES SEND SQRT :YVAR :FIT-MEANS IF-ELSE) 0 NIL) GLIM-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:DEVIANCE-RESIDUALS) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Message args: ()
Returns the standardized deviance residuals, (Davison and Tsai, 1989)." :STANDARDIZED-DEVIANCE-RESIDUALS #K(#(80 2 1 0 6 38 1 3 23 2 3 2 1 3 38 3 4 23 2 4 2 1 4 38 4 5 23 2 5 2 1 5 38 5 6 23 2 6 2 1 6 2 45 2 5 7 2 42 6 7 6 23 6 6 1 6 2 47 3 6 6 38 5 7 23 2 7 2 1 7 2 43 2 5 8 2 42 7 8 7 23 6 7 1 7 2 47 3 7 7 25 7 0 3 4 6 7) #(0) #(1 :DEVIANCE-RESIDUALS SEND :INCLUDED :LEVERAGES :SCALE SQRT IF-ELSE) 0 NIL) GLIM-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:STANDARDIZED-DEVIANCE-RESIDUALS) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Message args: ()
Returns  a weighted combination of the standardized deviance and chi
residuals, (Davison and Tsai, 1989)." :G2-RESIDUALS #K(#(80 2 4 0 1 2 3 6 38 4 6 23 5 6 2 1 6 38 6 7 23 5 7 2 1 7 38 7 8 23 5 0 2 1 8 38 8 8 23 5 8 2 1 8 3 60 6 5 9 23 9 9 3 9 4 3 2 45 3 8 10 23 10 11 2 6 2 2 42 10 11 10 23 10 11 2 7 2 2 42 8 11 11 2 43 10 11 10 23 11 10 1 10 2 42 9 10 0 57 0) #(0) #(2 1 -1 0 :STANDARDIZED-DEVIANCE-RESIDUALS SEND :STANDARDIZED-CHI-RESIDUALS :INCLUDED :LEVERAGES IF-ELSE ^ SQRT) 0 NIL) GLIM-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:G2-RESIDUALS) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 2 0 1 4 38 2 3 39 3 4 23 4 5 1 3 21 0 1 2 5 0 3 5 1 3 23 5 5 1 3 23 6 3 2 4 5 0 2 4 16 4 5 21 1 4 5 4 38 7 6 23 8 0 3 3 6 5 17 4 4 16 4 5 21 1 4 5 4 38 9 6 23 8 0 4 3 6 1 2 23 10 0 2 1 3 11 0 1) #(0 22 27 32 49 70) #(NORMALREG-PROTO NIL GLIM-PROTO MAKE-OBJECT LISTP LIST APPLY :ADD-SLOT SEND :MAKE-PROTOTYPE SET) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 0 25 3 0 3 3 2 1) #(0) #("Args: (x y &rest args)
Returns a normal regression model. Accepts :LINK, :OFFSET and :VERBOSE
keywords in addition to the keywords accepted by regression-model." FUNCTION-DOCUMENTATION NORMALREG-MODEL %SET-GET) 0 NIL) #K(#(80 1 2 0 1 1 23 2 3 1 2 25 3 0 2 1 3) #(0) #(NORMALREG-MODEL #K(#(77 2 3 0 0 5 39 0 4 38 1 5 38 2 6 38 3 7 38 4 8 25 5 0 8 4 5 6 7 1 8 2 3) #(0) #(SEND NORMALREG-PROTO :NEW :X :Y APPLY) 0 NIL) BYTE-CODE-CLOSE XLISP::INSTALL-FUNCTION) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 2 0 1 4 38 2 3 39 3 4 23 4 5 1 3 21 0 1 2 5 0 3 5 1 3 23 5 5 1 3 23 6 3 2 4 5 0 2 4 16 4 5 21 1 4 5 4 38 7 6 23 8 0 3 3 6 5 17 4 4 16 4 5 21 1 4 5 4 38 9 6 23 8 0 4 3 6 1 2 23 10 0 2 1 3 11 0 1) #(0 22 27 32 49 70) #(POISSONREG-PROTO NIL GLIM-PROTO MAKE-OBJECT LISTP LIST APPLY :ADD-SLOT SEND :MAKE-PROTOTYPE SET) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :INITIAL-MEANS #K(#(80 2 1 0 1 38 1 3 23 2 3 2 1 3 25 3 0 2 3 2) #(0) #(0.5 :YVAR SEND PMAX) 0 NIL) POISSONREG-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:INITIAL-MEANS) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :FIT-VARIANCES #K(#(80 3 0 0 11 0 2) #(0) #() 0 NIL) POISSONREG-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:FIT-VARIANCES) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :FIT-DEVIANCES #K(#(80 3 3 0 1 2 3 38 3 6 23 4 6 2 1 6 2 47 6 2 7 3 60 5 7 8 23 5 7 3 8 7 4 23 6 7 1 7 2 42 6 7 7 2 45 6 2 8 2 45 7 8 6 2 42 3 6 6 38 7 7 23 4 7 2 1 7 21 0 1 2 7 2 42 7 6 0 57 0 11 0 6) #(0 72 79) #(2 1 0 :YVAR SEND IF-ELSE LOG :PWEIGHTS) 0 NIL) POISSONREG-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:FIT-DEVIANCES) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 2 38 1 2 38 2 3 25 3 0 3 2 3 1) #(0) #(NIL POISSONREG-PROTO :ESTIMATE-SCALE SEND) 0 NIL)
#K(#(80 1 0 3 38 0 1 38 1 2 38 2 3 25 3 0 3 1 2 3) #(0) #(POISSONREG-PROTO :LINK LOG-LINK SEND) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 0 25 3 0 3 3 2 1) #(0) #("Args: (x y &rest args)
Returns a Poisson regression model. Accepts :LINK, :OFFSET and :VERBOSE
keywords in addition to the keywords accepted by regression-model." FUNCTION-DOCUMENTATION POISSONREG-MODEL %SET-GET) 0 NIL) #K(#(80 1 2 0 1 1 23 2 3 1 2 25 3 0 2 1 3) #(0) #(POISSONREG-MODEL #K(#(77 2 3 0 0 5 39 0 4 38 1 5 38 2 6 38 3 7 38 4 8 25 5 0 8 4 5 6 7 1 8 2 3) #(0) #(SEND POISSONREG-PROTO :NEW :X :Y APPLY) 0 NIL) BYTE-CODE-CLOSE XLISP::INSTALL-FUNCTION) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 0 25 3 0 3 3 2 1) #(0) #("Args: (x y &rest args)
Returns a Poisson regression model with a log link. Accepts :OFFSET and
:VERBOSE keywords in addition to the keywords accepted by regression-model." FUNCTION-DOCUMENTATION LOGLINREG-MODEL %SET-GET) 0 NIL) #K(#(80 1 2 0 1 1 23 2 3 1 2 25 3 0 2 1 3) #(0) #(LOGLINREG-MODEL #K(#(77 2 3 0 0 7 39 0 4 38 1 5 38 2 6 38 3 7 38 4 8 38 5 9 38 6 10 25 7 0 10 4 5 6 7 1 8 2 9 10 3) #(0) #(SEND POISSONREG-PROTO :NEW :X :Y :LINK LOG-LINK APPLY) 0 NIL) BYTE-CODE-CLOSE XLISP::INSTALL-FUNCTION) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 3 0 1 2 4 38 3 4 39 4 5 23 5 6 1 4 21 0 1 2 6 0 4 6 1 3 23 6 6 1 4 23 7 4 2 5 6 0 3 5 16 5 6 21 1 4 5 5 38 8 7 23 9 0 3 4 7 6 17 5 5 16 5 6 21 1 4 5 5 38 10 7 23 9 0 4 4 7 2 1 23 11 0 2 2 4 11 0 2) #(0 23 28 33 50 71) #((TRIALS) BINOMIALREG-PROTO NIL GLIM-PROTO MAKE-OBJECT LISTP LIST APPLY :ADD-SLOT SEND :MAKE-PROTOTYPE SET) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Message args: ()
Sets or retruns number of trials for each observation." :TRIALS #K(#(77 1 2 1 3 3 0 1 2 1 21 0 1 2 2 63 5 2 0 38 4 6 23 5 0 3 1 6 3 62 5 0 57 0) #(0 15 29) #(T NIL TRIALS #(NIL) :NEEDS-COMPUTING SEND) 0 NIL) BINOMIALREG-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:TRIALS) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :FIT-MEANS #K(#(77 1 2 1 0 0 3 21 2 1 2 2 0 2 3 1 3 38 1 3 23 2 3 2 1 3 38 3 4 23 2 4 2 1 4 23 4 5 1 3 2 42 4 5 0 57 0) #(0 12 17 26) #(#(%NOT-SUPPLIED) :ETA SEND :TRIALS CALL-NEXT-METHOD) 0 NIL) BINOMIALREG-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:FIT-MEANS) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :FIT-LINK-DERIVS #K(#(80 3 0 2 38 0 3 23 1 3 2 1 3 2 47 2 3 4 23 2 4 1 4 2 47 4 3 0 57 0) #(0) #(:TRIALS SEND CALL-NEXT-METHOD) 0 NIL) BINOMIALREG-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:FIT-LINK-DERIVS) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :INITIALIZE-SEARCH #K(#(77 1 2 1 0 0 3 21 0 1 2 2 0 2 3 1 3 38 1 3 23 2 3 2 1 3 38 3 4 38 4 5 23 2 5 2 1 5 23 2 3 3 3 4 5 25 5 0 1 3) #(0 12 17 45) #(#(NIL) :LINK SEND :ETA :INITIAL-PROBS CALL-NEXT-METHOD) 0 NIL) BINOMIALREG-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:INITIALIZE-SEARCH) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :INITIAL-PROBS #K(#(80 2 1 0 3 38 1 3 23 2 3 2 1 3 38 3 4 23 2 4 2 1 4 2 45 3 2 5 23 4 4 2 4 5 23 5 4 2 4 2 2 47 4 3 3 11 0 3) #(0) #(0.5 :TRIALS SEND :YVAR PMIN PMAX) 0 NIL) BINOMIALREG-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:INITIAL-PROBS) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :INITIAL-MEANS #K(#(80 2 0 2 38 0 2 23 1 2 2 1 2 38 2 3 23 1 3 2 1 3 2 42 2 3 0 57 0) #(0) #(:TRIALS SEND :INITIAL-PROBS) 0 NIL) BINOMIALREG-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:INITIAL-MEANS) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :FIT-VARIANCES #K(#(80 3 1 0 3 38 1 4 23 2 4 2 1 4 2 47 2 4 5 2 45 3 5 6 25 3 0 3 4 5 6) #(0) #(1 :TRIALS SEND *) 0 NIL) BINOMIALREG-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:FIT-VARIANCES) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :FIT-DEVIANCES #K(#(80 3 1 0 7 38 1 4 23 2 4 2 1 4 38 3 5 23 2 5 2 1 5 2 45 4 5 6 2 45 4 2 7 38 4 8 23 2 8 2 1 8 2 47 5 2 9 27 3 9 1 9 2 42 5 9 9 2 47 6 7 10 27 3 10 1 10 2 42 6 10 10 2 43 9 10 9 2 42 3 9 9 21 0 1 2 8 2 42 8 9 0 57 0 11 0 9 80 2 2 5 6 1 3 60 3 1 4 23 7 4 3 4 1 2 25 8 0 1 4) #(0 87 94 97) #(2 :TRIALS SEND :YVAR :PWEIGHTS 1 0 IF-ELSE LOG) 0 NIL) BINOMIALREG-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:FIT-DEVIANCES) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Message args: ()
Returns the fitted probabilities for the model." :FIT-PROBABILITIES #K(#(80 2 0 2 38 0 2 23 1 2 2 1 2 38 2 3 23 1 3 2 1 3 2 47 2 3 0 57 0) #(0) #(:FIT-MEANS SEND :TRIALS) 0 NIL) BINOMIALREG-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:FIT-PROBABILITIES) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :ISNEW #K(#(77 3 2 0 1 0 1 0 0 1 38 2 4 23 3 0 3 1 4 3 39 4 4 25 5 0 2 4 2) #(0) #((NIL) (:TRIALS) :TRIALS SEND CALL-NEXT-METHOD APPLY) 0 NIL) BINOMIALREG-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:ISNEW) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 2 38 1 2 38 2 3 25 3 0 3 2 3 1) #(0) #(NIL BINOMIALREG-PROTO :ESTIMATE-SCALE SEND) 0 NIL)
#K(#(80 1 0 3 38 0 1 38 1 2 38 2 3 25 3 0 3 1 2 3) #(0) #(BINOMIALREG-PROTO :LINK LOGIT-LINK SEND) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 0 25 3 0 3 3 2 1) #(0) #("Args: (x y n &rest args)
Returns a binomial regression model. Accepts :LINK, :OFFSET and :VERBOSE
keywords in addition to the keywords accepted by regression-model." FUNCTION-DOCUMENTATION BINOMIALREG-MODEL %SET-GET) 0 NIL) #K(#(80 1 2 0 1 1 23 2 3 1 2 25 3 0 2 1 3) #(0) #(BINOMIALREG-MODEL #K(#(77 2 4 0 0 6 39 0 5 38 1 6 38 2 7 38 3 8 38 4 9 38 5 10 25 6 0 10 5 6 7 8 1 9 2 10 3 4) #(0) #(SEND BINOMIALREG-PROTO :NEW :X :Y :TRIALS APPLY) 0 NIL) BYTE-CODE-CLOSE XLISP::INSTALL-FUNCTION) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 0 25 3 0 3 3 2 1) #(0) #("Args: (x y n &rest args)
Returns a logistic regression model (binomial regression model with logit
link). Accepts :OFFSET and :VERBOSE keywords in addition to the keywords
accepted by regression-model." FUNCTION-DOCUMENTATION LOGITREG-MODEL %SET-GET) 0 NIL) #K(#(80 1 2 0 1 1 23 2 3 1 2 25 3 0 2 1 3) #(0) #(LOGITREG-MODEL #K(#(77 2 4 0 0 8 39 0 5 38 1 6 38 2 7 38 3 8 38 4 9 38 5 10 38 6 11 38 7 12 25 8 0 12 5 6 7 8 1 9 2 10 3 11 12 4) #(0) #(SEND BINOMIALREG-PROTO :NEW :X :Y :TRIALS :LINK LOGIT-LINK APPLY) 0 NIL) BYTE-CODE-CLOSE XLISP::INSTALL-FUNCTION) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 0 25 3 0 3 3 2 1) #(0) #("Args: (x y n &rest args)
Returns a probit regression model (binomial regression model with probit
link). Accepts :OFFSET and :VERBOSE keywords in addition to the keywords
accepted by regression-model." FUNCTION-DOCUMENTATION PROBITREG-MODEL %SET-GET) 0 NIL) #K(#(80 1 2 0 1 1 23 2 3 1 2 25 3 0 2 1 3) #(0) #(PROBITREG-MODEL #K(#(77 2 4 0 0 8 39 0 5 38 1 6 38 2 7 38 3 8 38 4 9 38 5 10 38 6 11 38 7 12 25 8 0 12 5 6 7 8 1 9 2 10 3 11 12 4) #(0) #(SEND BINOMIALREG-PROTO :NEW :X :Y :TRIALS :LINK PROBIT-LINK APPLY) 0 NIL) BYTE-CODE-CLOSE XLISP::INSTALL-FUNCTION) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 2 0 1 4 38 2 3 39 3 4 23 4 5 1 3 21 0 1 2 5 0 3 5 1 3 23 5 5 1 3 23 6 3 2 4 5 0 2 4 16 4 5 21 1 4 5 4 38 7 6 23 8 0 3 3 6 5 17 4 4 16 4 5 21 1 4 5 4 38 9 6 23 8 0 4 3 6 1 2 23 10 0 2 1 3 11 0 1) #(0 22 27 32 49 70) #(GAMMAREG-PROTO NIL GLIM-PROTO MAKE-OBJECT LISTP LIST APPLY :ADD-SLOT SEND :MAKE-PROTOTYPE SET) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :INITIAL-MEANS #K(#(80 2 1 0 1 38 1 3 23 2 3 2 1 3 25 3 0 2 3 2) #(0) #(0.5 :YVAR SEND PMAX) 0 NIL) GAMMAREG-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:INITIAL-MEANS) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :FIT-VARIANCES #K(#(80 3 1 0 0 25 1 0 2 2 3) #(0) #(2 ^) 0 NIL) GAMMAREG-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:FIT-VARIANCES) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :FIT-DEVIANCES #K(#(80 3 1 0 4 38 1 4 23 2 4 2 1 4 38 3 5 23 2 5 2 1 5 2 47 4 2 6 23 4 6 1 6 61 45 6 6 2 45 4 2 7 2 47 7 2 7 2 43 6 7 6 2 42 3 6 6 21 0 1 2 5 2 42 6 5 0 57 0 11 0 6) #(0 62 69) #(2 :YVAR SEND :PWEIGHTS LOG) 0 NIL) GAMMAREG-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:FIT-DEVIANCES) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 0 3 38 0 1 38 1 2 38 2 3 25 3 0 3 1 2 3) #(0) #(GAMMAREG-PROTO :LINK INVERSE-LINK SEND) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 0 25 3 0 3 3 2 1) #(0) #("Args: (x y &rest args)
Returns a Gamma regression model. Accepts :LINK, :OFFSET and :VERBOSE
keywords in addition to the keywords accepted by regression-model." FUNCTION-DOCUMENTATION GAMMAREG-MODEL %SET-GET) 0 NIL) #K(#(80 1 2 0 1 1 23 2 3 1 2 25 3 0 2 1 3) #(0) #(GAMMAREG-MODEL #K(#(77 2 3 0 0 5 39 0 4 38 1 5 38 2 6 38 3 7 38 4 8 25 5 0 8 4 5 6 7 1 8 2 3) #(0) #(SEND GAMMAREG-PROTO :NEW :X :Y APPLY) 0 NIL) BYTE-CODE-CLOSE XLISP::INSTALL-FUNCTION) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 0 25 3 0 3 3 2 1) #(0) #("Args: (x &key (drop-first t) (test #'eql))
Returns a list of indicators sequences for the levels of X. TEST is
used to check equality of levels. If DROP-FIRST is true, the indicator
for the first level is dropped." FUNCTION-DOCUMENTATION INDICATORS %SET-GET) 0 NIL) #K(#(80 1 2 0 1 1 23 2 3 1 2 25 3 0 2 1 3) #(0) #(INDICATORS #K(#(77 3 2 0 0 0 2 1 1 0 3 21 2 1 2 3 0 3 5 1 3 39 3 5 23 4 6 2 1 4 23 5 6 1 6 21 0 4 5 2 17 6 6 51 6 7 2 1 5 25 6 0 2 7 6 80 4 2 7 8 1 23 9 6 3 2 3 1 25 10 0 3 6 5 4) #(0 16 21 24 40 43 55) #(LIST (T %NOT-SUPPLIED) (:DROP-FIRST :TEST) EQL COERCE REMOVE-DUPLICATES MAPCAR 0 1 MAP-ELEMENTS IF-ELSE) 0 NIL) BYTE-CODE-CLOSE XLISP::INSTALL-FUNCTION) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 0 25 3 0 3 3 2 1) #(0) #("Args: (x &rest args)
Arguments should be lists. Returns list of cross products, with the first
argument list varying slowest." FUNCTION-DOCUMENTATION CROSS-TERMS %SET-GET) 0 NIL) #K(#(80 1 2 0 1 1 23 2 3 1 2 25 3 0 2 1 3) #(0) #(CROSS-TERMS #K(#(77 2 2 0 2 0 1 3 23 2 5 1 2 60 5 4 3 2 1 39 3 5 23 4 5 2 5 2 25 3 0 2 1 5 16 2 5 39 5 6 51 5 7 1 5 23 6 7 2 7 1 25 4 0 2 6 7 25 7 0 1 3 80 3 0 0 2 42 1 2 0 57 0 80 3 0 1 51 4 3 1 2 25 6 0 2 3 1) #(0 19 34 57 62 73) #("too few arguments" #(0 1) LENGTH CROSS-TERMS APPLY APPEND MAPCAR ERROR) 0 NIL) BYTE-CODE-CLOSE XLISP::INSTALL-FUNCTION) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 0 25 3 0 3 3 2 1) #(0) #("Args: (x &key (prefix \"\") (drop-first t))
Constructs name strings using unique levels in X and PREFIX." FUNCTION-DOCUMENTATION LEVEL-NAMES %SET-GET) 0 NIL) #K(#(80 1 2 0 1 1 23 2 3 1 2 25 3 0 2 1 3) #(0) #(LEVEL-NAMES #K(#(77 3 2 0 0 0 2 1 1 0 2 23 3 5 2 1 4 23 4 5 1 5 21 0 1 2 3 17 5 5 51 3 6 1 2 25 5 0 2 6 5 80 3 2 6 7 0 25 8 0 4 4 3 1 2) #(0 27 30 41) #(LIST ("" T) (:PREFIX :DROP-FIRST) COERCE REMOVE-DUPLICATES MAPCAR "~a(~a)" NIL FORMAT) 0 NIL) BYTE-CODE-CLOSE XLISP::INSTALL-FUNCTION) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 0 25 3 0 3 3 2 1) #(0) #("Args: (x &rest args)
Arguments should be lists. Constructs cross products of names, separated
by dots. First index varies slowest." FUNCTION-DOCUMENTATION CROSS-NAMES %SET-GET) 0 NIL) #K(#(80 1 2 0 1 1 23 2 3 1 2 25 3 0 2 1 3) #(0) #(CROSS-NAMES #K(#(77 2 2 0 2 0 1 3 23 2 5 1 2 60 5 4 3 2 1 39 3 5 23 4 5 2 5 2 25 3 0 2 1 5 16 2 5 39 5 6 51 5 7 1 5 23 6 7 2 7 1 25 4 0 2 6 7 25 7 0 1 3 80 3 2 8 9 0 25 10 0 4 4 3 1 2 80 3 0 1 51 4 3 1 2 25 6 0 2 3 1) #(0 19 34 57 62 76) #("too few arguments" #(0 1) LENGTH CROSS-NAMES APPLY APPEND MAPCAR ERROR "~a.~a" NIL FORMAT) 0 NIL) BYTE-CODE-CLOSE XLISP::INSTALL-FUNCTION) 0 NIL)) EVAL) 0 NIL)
