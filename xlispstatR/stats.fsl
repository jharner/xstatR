(XLISP::CHECK-FSL-VERSION 1 4)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #("stats" PROVIDE) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 0 25 3 0 3 3 2 1) #(0) #(SET-SELECT *SETF* SELECT %SET-GET) 0 NIL) #K(#(80 1 2 0 1 0 25 2 0 2 2 1) #(0) #(*SETF-LAMBDA* SELECT REMPROP) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(SELECT) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 0 25 3 0 3 3 2 1) #(0) #("Args: (fname)
Returns the number of lisp items on the first nonblank line of file FNAME." FUNCTION-DOCUMENTATION COUNT-FILE-COLUMNS %SET-GET) 0 NIL) #K(#(80 1 2 0 1 1 23 2 3 1 2 25 3 0 2 1 3) #(0) #(COUNT-FILE-COLUMNS #K(#(80 2 4 0 1 2 3 7 23 4 6 1 1 56 4 1 7 7 57 0 21 0 2 3 6 25 5 7 1 6 11 7 5 21 0 5 22 6 23 6 8 1 6 0 8 9 21 0 6 7 9 0 5 9 1 8 0 2 9 21 0 10 9 9 23 7 10 1 8 3 60 4 10 9 21 0 17 11 9 23 6 8 1 6 0 8 9 21 0 12 13 9 0 5 9 1 14 0 2 9 21 0 16 15 9 23 7 10 1 8 3 60 4 10 9 21 0 17 11 9 0 8 9 21 0 18 21 9 23 8 9 3 9 4 5 23 9 10 0 0 4 11 23 10 12 3 9 5 10 50 0 20 19 10 12 2 43 11 3 11 23 10 12 3 9 5 10 50 0 20 19 10 12 11 7 11 11 7 5 11 7 5) #(0 20 25 30 33 38 51 56 59 64 74 79 92 97 100 105 115 120 128 155 173 176 179) #(T 1 0 NIL OPEN CLOSE READ-LINE LENGTH MAKE-STRING-INPUT-STREAM GENSYM READ) 0 NIL) BYTE-CODE-CLOSE XLISP::INSTALL-FUNCTION) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 1 0 0 25 1 0 1 1) #(0) #(*XLISPTABLE* MARK-AS-SPECIAL) 0 NIL) #K(#(80 1 2 0 1 1 23 2 3 1 2 21 0 1 2 3 11 0 1 38 3 3 25 4 0 2 2 3) #(0 16 19) #(NIL *XLISPTABLE* BOUNDP *READTABLE* SET) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(*XLISPTABLE*) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 2 0 1 1 23 2 3 1 2 21 0 1 2 3 11 0 1 51 3 3 0 25 3 0 2 2 3 77 1 1 1 6 2 4 5 1 23 7 4 0 21 0 4 5 4 25 8 0 1 2 25 9 0 1 3) #(0 16 19 29 47 52) #(NIL OPEN-FILE-DIALOG FBOUNDP XLISP::INSTALL-FUNCTION "Enter a data file name:" "You must provide a file name explicitly" #(NIL) SYSTEM-HAS-WINDOWS GET-STRING-DIALOG ERROR) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 0 25 3 0 3 3 2 1) #(0) #("Args:  (file)
Returns a list of all lisp objects in FILE. FILE can be a string or a symbol,
in which case the symbol'f print name is used." FUNCTION-DOCUMENTATION READ-DATA-FILE %SET-GET) 0 NIL) #K(#(80 1 2 0 1 1 23 2 3 1 2 25 3 0 2 1 3) #(0) #(READ-DATA-FILE #K(#(77 1 1 1 2 2 0 1 11 21 2 1 2 1 0 1 4 1 3 23 3 4 1 2 21 0 4 15 4 38 4 5 38 5 6 23 6 7 0 38 7 8 49 4 8 0 49 5 3 0 23 8 8 1 4 56 8 5 9 9 57 0 21 0 6 7 8 25 9 9 1 8 11 9 3 21 0 9 14 8 56 11 10 10 10 57 9 49 5 6 0 49 4 5 0 57 10 23 10 11 3 8 3 7 23 11 12 1 3 0 12 13 50 0 13 12 11 7 23 11 14 1 11 79 13 14 0 23 10 11 3 8 3 7 17 13 13 50 0 13 12 11 7 17 12 0 57 10 11 9 3 11 0 3) #(0 14 19 24 29 62 67 72 75 80 87 97 118 143 148 151) #(T NIL #(%NOT-SUPPLIED) OPEN-FILE-DIALOG *READTABLE* *BREAKENABLE* GENSYM *XLISPTABLE* OPEN CLOSE READ LIST) 0 NIL) BYTE-CODE-CLOSE XLISP::INSTALL-FUNCTION) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 0 25 3 0 3 3 2 1) #(0) #("Args: (&optional file cols)
Reads the data in FILE as COLS columns and returns a list of lists representing the columns." FUNCTION-DOCUMENTATION READ-DATA-COLUMNS %SET-GET) 0 NIL) #K(#(80 1 2 0 1 1 23 2 3 1 2 25 3 0 2 1 3) #(0) #(READ-DATA-COLUMNS #K(#(77 1 1 2 2 2 0 1 3 21 2 1 2 1 0 1 5 1 3 23 3 5 1 3 21 2 4 5 2 0 2 6 1 8 21 0 6 7 5 23 4 6 1 5 1 8 0 4 6 21 0 9 11 5 21 0 10 11 6 23 5 7 1 5 23 6 7 2 7 6 25 7 0 1 7 11 0 4) #(0 14 19 24 29 34 39 46 49 54 59 75) #(T NIL #(%NOT-SUPPLIED %NOT-SUPPLIED) OPEN-FILE-DIALOG COUNT-FILE-COLUMNS READ-DATA-FILE SPLIT-LIST TRANSPOSE) 0 NIL) BYTE-CODE-CLOSE XLISP::INSTALL-FUNCTION) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 0 25 3 0 3 3 2 1) #(0) #("Args: (file)
Read in data file from the data examples library." FUNCTION-DOCUMENTATION LOAD-DATA %SET-GET) 0 NIL) #K(#(80 1 2 0 1 1 23 2 3 1 2 25 3 0 2 1 3) #(0) #(LOAD-DATA #K(#(80 2 1 0 1 38 1 3 23 2 3 2 3 2 23 3 3 2 1 3 25 4 0 1 3) #(0) #((:RELATIVE "Data") :DIRECTORY MAKE-PATHNAME MERGE-PATHNAMES LOAD) 0 NIL) BYTE-CODE-CLOSE XLISP::INSTALL-FUNCTION) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 0 25 3 0 3 3 2 1) #(0) #("Args: (file)
Read in lisp example file from the examples library." FUNCTION-DOCUMENTATION LOAD-EXAMPLE %SET-GET) 0 NIL) #K(#(80 1 2 0 1 1 23 2 3 1 2 25 3 0 2 1 3) #(0) #(LOAD-EXAMPLE #K(#(80 2 1 0 1 38 1 3 23 2 3 2 3 2 23 3 3 2 1 3 25 4 0 1 3) #(0) #((:RELATIVE "Examples") :DIRECTORY MAKE-PATHNAME MERGE-PATHNAMES LOAD) 0 NIL) BYTE-CODE-CLOSE XLISP::INSTALL-FUNCTION) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 1 0 0 25 1 0 1 1) #(0) #(*VARIABLES* MARK-AS-SPECIAL) 0 NIL) #K(#(80 1 2 0 1 1 23 2 3 1 2 21 0 1 2 3 11 0 1 25 3 0 2 2 1) #(0 16 19) #(NIL *VARIABLES* BOUNDP SET) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(*VARIABLES*) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 1 0 0 25 1 0 1 1) #(0) #(*ASK-ON-REDEFINE* MARK-AS-SPECIAL) 0 NIL) #K(#(80 1 2 0 1 1 23 2 3 1 2 21 0 1 2 3 11 0 1 25 3 0 2 2 1) #(0 16 19) #(NIL *ASK-ON-REDEFINE* BOUNDP SET) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(*ASK-ON-REDEFINE*) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 0 25 3 0 3 3 2 1) #(0) #("Syntax: (def var form)
VAR is not evaluated and must be a symbol.  Assigns the value of FORM to
VAR and adds VAR to the list *VARIABLES* of def'ed variables. Returns VAR.
If VAR is already bound and the global variable *ASK-ON-REDEFINE*
is not nil then you are asked if you want to redefine the variable." FUNCTION-DOCUMENTATION DEF %SET-GET) 0 NIL) #K(#(80 1 1 0 1 51 2 2 0 23 1 2 1 2 25 2 0 2 1 2 80 3 11 3 4 5 6 7 8 9 10 11 12 13 7 23 14 14 1 13 23 14 15 1 12 23 14 16 1 11 23 14 17 1 10 23 14 18 1 9 23 14 19 1 1 23 15 18 2 18 19 23 14 18 1 18 23 15 17 2 17 18 23 14 17 1 17 23 14 18 1 8 23 14 19 1 7 23 14 20 1 6 23 15 19 2 19 20 23 14 19 1 19 23 15 18 2 18 19 23 14 18 1 18 23 15 15 4 15 16 17 18 23 14 15 1 15 23 14 16 1 5 23 14 17 1 9 23 14 18 1 1 23 15 17 2 17 18 23 14 17 1 17 23 14 18 1 4 23 15 16 3 16 17 18 23 14 16 1 16 23 14 17 1 3 23 14 18 1 1 23 14 19 1 2 23 15 17 3 17 18 19 23 14 17 1 17 23 14 18 1 9 23 14 19 1 1 23 15 18 2 18 19 23 14 18 1 18 25 15 0 5 14 15 16 17 18 80 3 0 2 17 1 3 51 1 4 0 25 16 0 2 4 3) #(0 20 237) #(DEF COERCE-TO-MACRO XLISP::INSTALL-FUNCTION SETF *VARIABLES* PUSHNEW "Variable has a value. Redefine?" Y-OR-N-P NOT QUOTE BOUNDP *ASK-ON-REDEFINE* AND UNLESS LIST APPEND APPLY) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 0 25 3 0 3 3 2 1) #(0) #("Args:()
Returns a list of the names of all def'ed variables." FUNCTION-DOCUMENTATION VARIABLES %SET-GET) 0 NIL) #K(#(80 1 2 0 1 1 23 2 3 1 2 25 3 0 2 1 3) #(0) #(VARIABLES #K(#(80 1 0 2 38 0 1 23 1 1 1 1 39 2 2 25 3 0 2 1 2) #(0) #(*VARIABLES* COPY-LIST STRING<= SORT) 0 NIL) BYTE-CODE-CLOSE XLISP::INSTALL-FUNCTION) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 0 25 3 0 3 3 2 1) #(0) #("Args: (vars file-name-root)
VARS is a symbol or a list of symbols. FILE-NAME-ROOT is a string (or a symbol
whose print name is used) not endinf in .lsp. The VARS and their current values
are written to the file FILE-NAME-ROOT.lsp in a form suitable for use with the
load command." FUNCTION-DOCUMENTATION SAVEVAR %SET-GET) 0 NIL) #K(#(80 1 2 0 1 1 23 2 3 1 2 25 3 0 2 1 3) #(0) #(SAVEVAR #K(#(80 3 3 0 1 2 5 23 2 6 1 2 23 3 6 3 5 6 4 38 4 7 38 5 8 23 6 6 3 6 7 8 21 1 1 2 1 0 1 7 1 3 23 7 7 1 1 38 8 8 49 8 3 0 56 5 4 9 9 11 0 7 49 8 8 0 25 9 9 1 6 51 6 10 1 6 25 10 9 2 10 7 80 3 2 11 12 4 23 13 5 1 2 23 14 5 1 5 21 0 7 8 5 23 7 5 1 4 23 7 6 1 2 23 13 7 1 2 38 15 8 23 16 7 2 7 8 23 7 7 1 7 23 17 5 3 5 6 7 25 18 0 2 5 1 23 7 5 1 4 23 7 6 1 2 23 7 7 1 3 23 13 8 1 2 23 7 8 1 8 23 17 7 2 7 8 23 7 7 1 7 23 17 5 3 5 6 7 25 18 0 2 5 1) #(0 37 42 47 62 71 82 103 145) #(NIL ".lsp" STRING CONCATENATE :DIRECTION :OUTPUT OPEN LIST *BREAKENABLE* CLOSE MAPCAR QUOTE DEF SYMBOL-VALUE OBJECTP :SAVE SEND APPEND PRINT) 0 NIL) BYTE-CODE-CLOSE XLISP::INSTALL-FUNCTION) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 0 25 3 0 3 3 2 1) #(0) #("Args: (v)
If V is the symbol of a defined variable the variable it is unbound and
removed from the list of defined variables. If V is a list of variable
names each is unbound and removed. Returns V." FUNCTION-DOCUMENTATION UNDEF %SET-GET) 0 NIL) #K(#(80 1 2 0 1 1 23 2 3 1 2 25 3 0 2 1 3) #(0) #(UNDEF #K(#(80 2 1 0 4 23 1 3 1 1 21 0 1 2 3 0 1 3 1 3 23 2 3 1 1 16 3 4 21 1 4 7 3 38 3 5 23 4 5 2 4 5 21 0 5 6 5 38 3 6 23 5 6 2 4 6 49 3 6 0 23 6 0 1 4 17 3 3 16 3 4 21 1 4 7 3 11 0 1) #(0 15 20 25 33 47 65 76) #(NIL LISTP LIST *VARIABLES* MEMBER DELETE MAKUNBOUND) 0 NIL) BYTE-CODE-CLOSE XLISP::INSTALL-FUNCTION) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 0 25 3 0 3 3 2 1) #(0) #("Args: (x)
Returns the standard deviation of the elements x. Vector reducing." FUNCTION-DOCUMENTATION STANDARD-DEVIATION %SET-GET) 0 NIL) #K(#(80 1 2 0 1 1 23 2 3 1 2 25 3 0 2 1 3) #(0) #(STANDARD-DEVIATION #K(#(80 2 1 0 3 23 1 3 1 1 23 2 4 1 1 2 45 1 4 4 2 42 4 4 4 23 2 4 1 4 2 45 3 2 5 2 47 3 5 5 2 42 4 5 3 25 3 0 1 3) #(0) #(1 COUNT-ELEMENTS MEAN SQRT) 0 NIL) BYTE-CODE-CLOSE XLISP::INSTALL-FUNCTION) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 0 25 3 0 3 3 2 1) #(0) #("Args: (x p)
Returns the P-th quantile(s) of sequence X. P can be a number or a sequence." FUNCTION-DOCUMENTATION QUANTILE %SET-GET) 0 NIL) #K(#(80 1 2 0 1 1 23 2 3 1 2 25 3 0 2 1 3) #(0) #(QUANTILE #K(#(80 3 2 0 1 6 23 2 5 1 1 23 3 6 1 5 2 45 6 4 6 2 42 2 6 6 23 4 7 1 6 23 5 8 1 6 23 6 9 2 5 7 23 6 10 2 5 8 2 43 9 10 5 2 47 5 3 0 57 0) #(0) #(2 1 SORT-DATA LENGTH FLOOR CEILING SELECT) 0 NIL) BYTE-CODE-CLOSE XLISP::INSTALL-FUNCTION) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 0 25 3 0 3 3 2 1) #(0) #("Args: (x)
Returns the median of the elements of X." FUNCTION-DOCUMENTATION MEDIAN %SET-GET) 0 NIL) #K(#(80 1 2 0 1 1 23 2 3 1 2 25 3 0 2 1 3) #(0) #(MEDIAN #K(#(80 2 1 0 0 25 1 0 2 1 2) #(0) #(0.5 QUANTILE) 0 NIL) BYTE-CODE-CLOSE XLISP::INSTALL-FUNCTION) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 0 25 3 0 3 3 2 1) #(0) #("Args: (number-data)
Returns the interquartile range of the elements of X." FUNCTION-DOCUMENTATION INTERQUARTILE-RANGE %SET-GET) 0 NIL) #K(#(80 1 2 0 1 1 23 2 3 1 2 25 3 0 2 1 3) #(0) #(INTERQUARTILE-RANGE #K(#(80 2 1 0 2 39 1 3 23 2 4 2 1 2 25 3 0 2 3 4) #(0) #((0.75 0.25) - QUANTILE APPLY) 0 NIL) BYTE-CODE-CLOSE XLISP::INSTALL-FUNCTION) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 0 25 3 0 3 3 2 1) #(0) #("Args: (number-data)
Returns the five number summary (min, 1st quartile, medinan, 3rd quartile,
max) of the elements X." FUNCTION-DOCUMENTATION FIVNUM %SET-GET) 0 NIL) #K(#(80 1 2 0 1 1 23 2 3 1 2 25 3 0 2 1 3) #(0) #(FIVNUM #K(#(80 2 1 0 0 25 1 0 2 1 2) #(0) #((0 0.25 0.5 0.75 1) QUANTILE) 0 NIL) BYTE-CODE-CLOSE XLISP::INSTALL-FUNCTION) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 0 25 3 0 3 3 2 1) #(0) #("Args: (&rest args)
Returns the sample covariance matrix of the data columns in ARGS. ARGS may
consist of lists, vectors or matrices." FUNCTION-DOCUMENTATION COVARIANCE-MATRIX %SET-GET) 0 NIL) #K(#(80 1 2 0 1 1 23 2 3 1 2 25 3 0 2 1 3) #(0) #(COVARIANCE-MATRIX #K(#(77 2 1 0 1 0 3 39 1 3 51 1 4 0 23 2 4 2 4 1 23 3 3 2 3 4 39 4 4 39 5 5 23 2 5 2 5 3 2 45 3 5 5 23 3 4 2 4 5 23 6 4 1 4 16 3 5 23 7 5 1 5 2 45 5 2 5 2 47 4 5 0 57 0 80 2 0 1 23 8 2 1 1 21 0 2 3 2 25 9 0 1 1 25 10 0 1 1) #(0 74 88 93) #(1 APPEND MAPCAR APPLY BIND-COLUMNS MEAN CROSS-PRODUCT LENGTH MATRIXP COLUMN-LIST LIST) 0 NIL) BYTE-CODE-CLOSE XLISP::INSTALL-FUNCTION) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 0 25 3 0 3 3 2 1) #(0) #("Args: (x)
Returns differences for a sequence X." FUNCTION-DOCUMENTATION DIFFERENCE %SET-GET) 0 NIL) #K(#(80 1 2 0 1 1 23 2 3 1 2 25 3 0 2 1 3) #(0) #(DIFFERENCE #K(#(80 2 3 0 1 2 3 23 3 5 1 1 61 109 5 6 23 4 6 2 4 6 23 5 6 2 1 6 2 45 5 3 7 23 4 7 2 2 7 23 5 7 2 1 7 2 45 6 7 0 57 0) #(0) #(0 2 1 LENGTH ISEQ SELECT) 0 NIL) BYTE-CODE-CLOSE XLISP::INSTALL-FUNCTION) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 0 25 3 0 3 3 2 1) #(0) #("Args: (a b num)
Returns a list of NUM equally spaced points starting at A and ending at B." FUNCTION-DOCUMENTATION RSEQ %SET-GET) 0 NIL) #K(#(80 1 2 0 1 1 23 2 3 1 2 25 3 0 2 1 3) #(0) #(RSEQ #K(#(80 4 1 0 3 61 109 3 5 23 1 5 2 4 5 2 45 2 1 6 61 109 3 7 2 47 6 7 6 2 42 5 6 5 2 43 1 5 0 57 0) #(0) #(0 ISEQ) 0 NIL) BYTE-CODE-CLOSE XLISP::INSTALL-FUNCTION) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 0 25 3 0 3 3 2 1) #(0) #("Args: (dim data)
returns a matrix of dimensions DIM initialized using sequence DATA
in row major order." FUNCTION-DOCUMENTATION MATRIX %SET-GET) 0 NIL) #K(#(80 1 2 0 1 1 23 2 3 1 2 25 3 0 2 1 3) #(0) #(MATRIX #K(#(80 3 2 0 1 4 23 2 5 2 1 4 23 2 6 2 2 4 38 3 7 48 3 5 8 23 4 8 2 6 8 25 5 0 3 5 7 8) #(0) #(1 LIST COERCE :INITIAL-CONTENTS SPLIT-LIST MAKE-ARRAY) 0 NIL) BYTE-CODE-CLOSE XLISP::INSTALL-FUNCTION) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 0 25 3 0 3 3 2 1) #(0) #("Args: (matrix &optional stream &key (float-digits 6))
Prints MATRIX to STREAM in a nice form that is still machine readable" FUNCTION-DOCUMENTATION PRINT-MATRIX %SET-GET) 0 NIL) #K(#(80 1 2 0 1 1 23 2 3 1 2 25 3 0 2 1 3) #(0) #(PRINT-MATRIX #K(#(77 3 2 1 16 0 0 15 14 14 0 1 2 3 4 5 6 7 8 9 10 11 12 13 10 21 2 1 2 2 0 2 18 1 3 38 17 18 23 18 19 1 1 21 0 5 4 19 23 19 0 2 4 1 2 43 17 3 19 34 16 20 51 17 21 2 19 20 23 20 0 2 21 1 23 21 0 2 18 15 23 22 21 1 1 16 21 22 21 1 6 16 21 23 21 0 2 18 12 23 23 23 1 22 0 16 24 37 60 7 15 24 23 7 22 24 25 23 24 26 1 25 21 0 8 9 26 35 20 27 2 45 27 6 27 23 21 0 4 18 5 27 25 1 12 23 25 27 1 25 21 0 10 11 27 35 20 27 23 21 0 5 18 7 27 3 25 1 12 35 20 27 23 21 0 4 18 8 27 25 0 24 25 2 45 23 10 26 37 60 13 14 25 26 23 21 0 2 18 9 61 112 24 24 37 60 7 15 24 23 23 21 0 2 18 11 17 21 21 16 21 22 21 1 6 16 21 23 21 0 2 18 14 11 0 13 80 4 1 2 3 35 2 5 23 25 6 1 3 21 0 18 19 6 0 1 6 1 22 23 24 7 1 3 21 0 20 21 7 23 26 7 1 3 2 43 7 4 6 1 22 23 26 6 1 3 2 77 5 6 5 36 2 5 0 57 0) #(0 30 35 38 48 54 93 113 127 145 155 169 180 194 200 210 227 236 254 259 269 281 286) #("not a matrix - ~a" "~vd~4@t" 4 "~v,vg" "~va" " " 1 ")~%" "    (" NIL "   )~%" "#2a(~%" 0 7 (6) (:FLOAT-DIGITS) #(%NOT-SUPPLIED) *STANDARD-OUTPUT* MATRIXP ERROR MAP-ELEMENTS FORMAT ROW-LIST LENGTH INTEGERP FLOATP FLATSIZE) 0 NIL) BYTE-CODE-CLOSE XLISP::INSTALL-FUNCTION) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 2 0 1 1 23 2 3 1 2 25 3 0 2 1 3) #(0) #(ARRAY-TO-NESTED-LIST #K(#(80 2 2 0 1 4 23 2 4 1 1 23 3 5 1 1 2 45 4 3 6 37 76 2 1 6 2 23 4 7 2 1 6 23 5 5 2 5 7 2 45 6 3 6 37 76 2 1 6 2 11 0 5) #(0 27 50) #(0 1 ARRAY-RANK COMBINE ARRAY-DIMENSION SPLIT-LIST) 0 NIL) BYTE-CODE-CLOSE XLISP::INSTALL-FUNCTION) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 0 25 3 0 3 3 2 1) #(0) #("Args: (a b)
Solves A x = B using LU decomposition and backsolving. B can be a sequence
or a matrix." FUNCTION-DOCUMENTATION SOLVE %SET-GET) 0 NIL) #K(#(80 1 2 0 1 1 23 2 3 1 2 25 3 0 2 1 3) #(0) #(SOLVE #K(#(80 3 0 4 23 0 3 1 1 23 1 4 1 2 21 0 1 2 4 39 2 4 23 3 5 1 2 51 3 6 1 3 23 4 5 2 6 5 25 5 0 2 4 5 25 6 0 2 3 2 80 3 0 0 25 6 0 2 1 2) #(0 19 44 50) #(LU-DECOMP MATRIXP BIND-COLUMNS COLUMN-LIST MAPCAR APPLY LU-SOLVE) 0 NIL) BYTE-CODE-CLOSE XLISP::INSTALL-FUNCTION) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 0 25 3 0 3 3 2 1) #(0) #("Args: (a b)
Solves A x = B by backsolving, assuming A is upper triangular. B must be a
sequence. For use with qr-decomp." FUNCTION-DOCUMENTATION BACKSOLVE %SET-GET) 0 NIL) #K(#(80 1 2 0 1 1 23 2 3 1 2 25 3 0 2 1 3) #(0) #(BACKSOLVE #K(#(80 3 3 0 1 2 10 23 3 6 1 2 23 4 7 1 6 0 5 8 37 60 1 4 8 6 23 5 9 3 6 8 3 9 2 9 10 0 8 11 0 5 12 37 60 2 3 12 11 23 5 13 3 6 12 3 7 7 13 14 68 1 9 13 15 2 42 14 15 13 2 45 10 13 10 61 112 12 12 37 60 2 3 12 11 68 1 9 9 13 2 47 10 13 13 6 7 9 13 0 61 112 8 8 37 60 1 4 8 6 23 6 9 1 2 21 0 5 6 9 25 7 0 2 7 4 11 0 7) #(0 26 49 85 110 120 126) #(1 LIST 0 LENGTH MAKE-ARRAY - LISTP COERCE) 0 NIL) BYTE-CODE-CLOSE XLISP::INSTALL-FUNCTION) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 0 25 3 0 3 3 2 1) #(0) #("Args: (a)
Returns list of eigenvalues of square, symmetric matrix A" FUNCTION-DOCUMENTATION EIGENVALUES %SET-GET) 0 NIL) #K(#(80 1 2 0 1 1 23 2 3 1 2 25 3 0 2 1 3) #(0) #(EIGENVALUES #K(#(80 2 0 1 23 0 2 1 1 16 2 0 57 0) #(0) #(EIGEN) 0 NIL) BYTE-CODE-CLOSE XLISP::INSTALL-FUNCTION) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 0 25 3 0 3 3 2 1) #(0) #("Args: (a)
Returns list of eigenvectors of square, symmetric matrix A" FUNCTION-DOCUMENTATION EIGENVECTORS %SET-GET) 0 NIL) #K(#(80 1 2 0 1 1 23 2 3 1 2 25 3 0 2 1 3) #(0) #(EIGENVECTORS #K(#(80 2 0 1 23 0 2 1 1 71 2 2 2 0 57 0) #(0) #(EIGEN) 0 NIL) BYTE-CODE-CLOSE XLISP::INSTALL-FUNCTION) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 0 25 3 0 3 3 2 1) #(0) #("Args: (f s)
Accumulates elements of sequence S using binary function F.
(accumulate #'+ x) returns the cumulative sum of x." FUNCTION-DOCUMENTATION ACCUMULATE %SET-GET) 0 NIL) #K(#(80 1 2 0 1 1 23 2 3 1 2 25 3 0 2 1 3) #(0) #(ACCUMULATE #K(#(80 3 2 0 1 2 9 2 4 5 23 2 5 1 5 34 5 6 51 3 6 2 1 6 23 3 0 2 6 2 23 4 6 1 2 21 0 1 2 6 25 5 0 2 5 3 11 0 5 80 5 0 2 35 2 5 35 2 6 16 6 6 31 1 6 2 6 4 23 2 6 1 6 19 5 6 0 35 2 5 17 5 5 36 2 5 0 57 0) #(0 40 46 49) #(VECTOR 0 LIST REDUCE VECTORP COERCE) 0 NIL) BYTE-CODE-CLOSE XLISP::INSTALL-FUNCTION) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 0 25 3 0 3 3 2 1) #(0) #("Args: (x)
Returns the cumulative sum of X." FUNCTION-DOCUMENTATION CUMSUM %SET-GET) 0 NIL) #K(#(80 1 2 0 1 1 23 2 3 1 2 25 3 0 2 1 3) #(0) #(CUMSUM #K(#(80 2 0 1 39 0 2 25 1 0 2 2 1) #(0) #(+ ACCUMULATE) 0 NIL) BYTE-CODE-CLOSE XLISP::INSTALL-FUNCTION) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 0 25 3 0 3 3 2 1) #(0) #("Args (&rest args) 
Returns sequence of elements of all arguments." FUNCTION-DOCUMENTATION COMBINE %SET-GET) 0 NIL) #K(#(80 1 2 0 1 1 23 2 3 1 2 25 3 0 2 1 3) #(0) #(COMBINE #K(#(77 2 1 0 0 1 23 0 2 1 1 25 1 0 1 2) #(0) #(ELEMENT-SEQ COPY-SEQ) 0 NIL) BYTE-CODE-CLOSE XLISP::INSTALL-FUNCTION) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 0 25 3 0 3 3 2 1) #(0) #("Args: (x y &key (f .25) (steps 2) delta sorted)
Returns (list X YS) with YS the LOWESS fit. F is the fraction of data used for
each point, STEPS is the number of robust iterations. Fits for points within
DELTA of each other are interpolated linearly. If the X values setting SORTED
to T speeds up the computation." FUNCTION-DOCUMENTATION LOWESS %SET-GET) 0 NIL) #K(#(80 1 2 0 1 1 23 2 3 1 2 25 3 0 2 1 3) #(0) #(LOWESS #K(#(77 3 3 0 0 0 8 7 7 0 1 2 3 4 5 6 8 23 9 14 2 1 13 23 9 15 2 2 13 21 0 1 2 6 12 2 14 15 1 3 23 10 16 1 14 23 11 17 2 14 16 23 11 18 2 15 16 12 2 17 18 59 2 14 15 23 12 16 1 14 38 13 17 23 14 17 3 16 17 12 38 13 18 23 14 18 3 16 18 12 38 13 19 23 14 19 3 16 19 12 37 62 4 5 5 8 0 5 20 1 6 23 15 20 1 14 23 16 21 1 14 2 45 20 21 20 2 47 20 7 20 23 17 18 9 14 15 16 3 4 20 17 18 19 21 0 7 8 18 23 18 0 1 9 23 9 18 2 14 11 23 9 19 2 17 11 25 4 0 2 18 19) #(0 34 40 61 106 111 131 149 154) #(50 0.0 "bad lowess data" NIL LIST C-DOUBLE (VECTOR C-DOUBLE) (0.25 2 -1 NIL) (:F :STEPS :DELTA :SORTED) COERCE ORDER SELECT LENGTH :ELEMENT-TYPE MAKE-ARRAY MAX MIN BASE-LOWESS ERROR) 0 NIL) BYTE-CODE-CLOSE XLISP::INSTALL-FUNCTION) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 1 0 0 25 1 0 1 1) #(0) #(*DEFAULT-SMOOTHER-POINTS* MARK-AS-SPECIAL) 0 NIL) #K(#(80 1 2 0 1 0 25 2 0 2 2 1) #(0) #(30 *DEFAULT-SMOOTHER-POINTS* SET) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(*DEFAULT-SMOOTHER-POINTS*) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 0 25 3 0 3 3 2 1) #(0) #("Args: (x y &key xvals)
Returns list of x and y values of natural cubic spline interpolation of (X,Y).
X must be strictly increasing. XVALS can be an integer, the number of equally
spaced points to use in the range of X, or it can be a sequence of points at 
which to interpolate." FUNCTION-DOCUMENTATION SPLINE %SET-GET) 0 NIL) #K(#(80 1 2 0 1 1 23 2 3 1 2 25 3 0 2 1 3) #(0) #(SPLINE #K(#(77 3 3 0 0 0 7 6 6 0 1 2 3 4 5 8 21 2 1 2 3 0 3 10 1 3 38 8 10 23 9 0 4 1 2 10 9 59 6 10 11 12 13 14 15 2 42 8 10 16 38 10 17 23 11 16 3 16 17 7 23 12 16 7 10 11 12 13 14 15 16 21 0 4 5 16 23 13 0 1 4 23 14 16 2 14 6 23 14 17 2 15 6 25 2 0 2 16 17) #(0 21 26 29 76 81) #("bad spline data" NIL LIST C-DOUBLE 2 T (%NOT-SUPPLIED) (:XVALS) *DEFAULT-SMOOTHER-POINTS* GET-SMOOTHER-DATA :ELEMENT-TYPE MAKE-ARRAY BASE-SPLINE ERROR COERCE) 0 NIL) BYTE-CODE-CLOSE XLISP::INSTALL-FUNCTION) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 0 25 3 0 3 3 2 1) #(0) #("Args: (x &key xvals width type)
Returns list of x and y values of kernel density estimate of X. XVALS can be an
integer, the number of equally spaced points to use in the range of X, or it
can be a sequence of points at which to interpolate. WIDTH specifies the
window width. TYPE specifies the lernel and should be one of the symbols G, T,
U or B for gaussian, triangular, uniform or bisquare. The default is B." FUNCTION-DOCUMENTATION KERNEL-DENS %SET-GET) 0 NIL) #K(#(80 1 2 0 1 1 23 2 3 1 2 25 3 0 2 1 3) #(0) #(KERNEL-DENS #K(#(77 3 2 0 0 0 4 3 3 0 1 2 8 21 2 1 2 2 0 2 8 1 3 38 5 8 23 6 0 4 1 7 8 7 59 6 8 9 10 11 12 13 23 7 14 8 8 9 10 11 12 13 3 4 21 0 4 5 14 23 8 0 1 5 23 9 14 2 12 6 23 9 15 2 13 6 25 1 0 2 14 15) #(0 18 23 26 59 64) #("bad data for smoother" LIST NIL (%NOT-SUPPLIED -1.0 B) (:XVALS :WIDTH :TYPE) *DEFAULT-SMOOTHER-POINTS* GET-SMOOTHER-DATA BASE-KERNEL-SMOOTH ERROR COERCE) 0 NIL) BYTE-CODE-CLOSE XLISP::INSTALL-FUNCTION) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 0 25 3 0 3 3 2 1) #(0) #("Args: (x y &key xvals width type)
Returns list of x and y values of kernel smooth of (X,Y). XVALS can be an
integer, the number of equally spaced points to use in the range of X, or it
can be a sequence of points at which to interpolate. WIDTH specifies the
window width. TYPE specifies the lernel and should be one of the symbols G, T,
U or B for Gaussian, triangular, uniform or bisquare. The default is B." FUNCTION-DOCUMENTATION KERNEL-SMOOTH %SET-GET) 0 NIL) #K(#(80 1 2 0 1 1 23 2 3 1 2 25 3 0 2 1 3) #(0) #(KERNEL-SMOOTH #K(#(77 3 3 0 0 0 5 4 4 0 1 2 3 8 21 2 1 2 3 0 3 10 1 3 38 6 10 23 7 0 4 1 2 10 9 59 6 10 11 12 13 14 15 23 8 16 8 10 11 12 13 14 15 4 5 21 0 4 5 16 23 9 0 1 6 23 10 16 2 14 8 23 10 17 2 15 8 25 2 0 2 16 17) #(0 19 24 27 60 65) #("bad data for smoother" NIL LIST T (%NOT-SUPPLIED -1.0 B) (:XVALS :WIDTH :TYPE) *DEFAULT-SMOOTHER-POINTS* GET-SMOOTHER-DATA BASE-KERNEL-SMOOTH ERROR COERCE) 0 NIL) BYTE-CODE-CLOSE XLISP::INSTALL-FUNCTION) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 2 0 1 1 23 2 3 1 2 25 3 0 2 1 3) #(0) #(SORT-DATA #K(#(80 2 1 0 2 23 1 3 1 1 21 0 1 2 3 23 2 3 1 1 1 3 23 3 4 1 1 23 4 3 2 4 2 39 5 4 25 6 0 2 3 4) #(0 15 22 33) #(LIST LISTP COPY-LIST COMPOUND-DATA-SEQ COERCE SORT-DATA< SORT) 0 NIL) BYTE-CODE-CLOSE XLISP::INSTALL-FUNCTION) 0 NIL)
#K(#(80 1 2 0 1 1 23 2 3 1 2 25 3 0 2 1 3) #(0) #(ORDER #K(#(80 2 1 0 3 23 1 3 1 1 21 0 1 2 3 0 1 3 1 3 23 2 4 1 1 23 3 3 2 4 2 39 4 4 23 5 5 1 3 23 6 5 1 5 23 7 3 3 4 3 5 39 8 4 23 9 3 2 3 4 39 10 4 25 7 0 2 4 3) #(0 15 20 31) #(LIST LISTP COMPOUND-DATA-SEQ COERCE CONS LENGTH ISEQ MAPCAR ORDER< SORT CDR) 0 NIL) BYTE-CODE-CLOSE XLISP::INSTALL-FUNCTION) 0 NIL)
#K(#(80 1 2 0 1 1 23 2 3 1 2 25 3 0 2 1 3) #(0) #(XLISP::MAKE-COMPOUND #K(#(80 3 3 0 1 2 3 23 3 6 1 1 21 0 1 2 6 25 4 0 2 2 3 23 5 6 1 1 21 0 3 4 6 25 6 0 2 5 2 23 7 6 1 1 21 0 5 6 6 25 4 0 2 2 4 23 8 6 1 1 21 0 7 8 6 23 9 6 1 1 38 10 7 23 4 8 2 2 4 25 11 0 3 6 7 8 25 6 0 2 5 2) #(0 17 23 33 39 49 55 65 86) #(LIST VECTOR "not a combound data item - ~s" LISTP COERCE STRINGP ERROR VECTORP ARRAYP ARRAY-DIMENSIONS :DISPLACED-TO MAKE-ARRAY) 0 NIL) BYTE-CODE-CLOSE XLISP::INSTALL-FUNCTION) 0 NIL)
#K(#(80 1 2 0 1 1 23 2 3 1 2 25 3 0 2 1 3) #(0) #(RANK #K(#(80 2 0 1 23 0 2 1 1 23 0 2 1 2 25 1 0 2 1 2) #(0) #(ORDER XLISP::MAKE-COMPOUND) 0 NIL) BYTE-CODE-CLOSE XLISP::INSTALL-FUNCTION) 0 NIL)
