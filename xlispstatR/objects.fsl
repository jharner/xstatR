(XLISP::CHECK-FSL-VERSION 1 4)
#K(#(80 1 3 0 1 2 1 23 3 4 1 3 21 0 2 1 4 23 4 0 2 2 3 49 5 4 0 57 0) #(0 17 23) #(NIL "can't find package ~s" "XLISP" FIND-PACKAGE ERROR *PACKAGE*) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #("objects" PROVIDE) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((EDIT-TEXT-ITEM-PROTO MODAL-DIALOG-PROTO MODAL-BUTTON-PROTO DASH-ITEM-PROTO) EXPORT) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 2 0 1 0 25 2 0 3 2 1 2) #(0) #(*SETF* SLOT-VALUE %SET-GET) 0 NIL) #K(#(80 1 2 0 1 0 25 2 0 2 2 1) #(0) #(*SETF-LAMBDA* SLOT-VALUE REMPROP) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(SLOT-VALUE) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Method args: (&rest args)
Creates new object using self as prototype." :NEW #K(#(77 2 2 0 2 0 1 6 23 2 5 1 1 62 4 6 21 0 1 3 6 62 4 7 16 7 8 21 1 2 3 7 38 3 9 62 8 10 23 4 0 4 5 9 8 10 17 7 7 16 7 8 21 1 2 3 7 39 4 6 38 5 7 23 6 0 4 6 5 7 2 11 0 5) #(0 21 32 57) #(NIL INSTANCE-SLOTS MAKE-OBJECT :ADD-SLOT SEND :ISNEW APPLY) 0 NIL) *OBJECT* BYTE-CODE-CLOSE ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:NEW) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Method args: (proto &rest args)
Changes object to inherit directly from prototype PROTO. PROTO
must be a prototype and SELF must not be one." :RETYPE #K(#(77 2 3 0 5 0 1 2 3 4 4 38 5 9 38 6 10 23 7 9 5 1 9 8 10 7 21 0 1 2 9 23 8 0 1 4 38 5 9 38 6 10 23 7 9 5 2 9 8 10 7 21 0 4 3 9 23 8 0 2 6 2 38 9 9 23 7 0 3 1 9 2 38 10 9 23 7 9 3 2 9 8 16 9 10 21 1 5 6 9 38 11 11 62 10 12 23 7 0 4 1 11 10 12 17 9 9 16 9 10 21 1 5 6 9 39 7 11 38 12 12 23 13 0 4 11 1 12 3 11 0 1) #(0 31 36 56 62 90 115) #("can't retype a prototype" NIL "not a prototype - ~a" T INSTANCE-SLOTS :HAS-SLOT :OWN SEND ERROR :REPARENT :SLOT-VALUE :ADD-SLOT :ISNEW APPLY) 0 NIL) *OBJECT* BYTE-CODE-CLOSE ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:RETYPE) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Method args: (&optional (stream *standard-output*))
Default object printing method." :PRINT #K(#(77 1 2 1 6 6 0 1 2 3 4 5 4 21 2 1 2 2 0 2 9 1 3 38 7 9 38 8 10 21 0 4 7 10 38 9 11 38 10 12 23 11 11 3 1 11 12 21 0 5 6 11 38 10 11 23 11 11 2 1 11 23 12 0 3 9 3 11 1 7 23 13 0 1 4 38 14 10 23 11 10 3 1 10 8 21 0 8 9 10 23 15 10 1 1 62 8 11 25 12 0 4 9 6 10 11 23 15 10 1 1 25 12 0 3 9 7 10) #(0 18 23 26 34 52 70 75 90 106) #("#.~s" "default :PRINT output is not readable" NIL "#<Object: ~D, prototype = ~A>" "#<Object: ~D>" PROTO-NAME #(%NOT-SUPPLIED) *STANDARD-OUTPUT* *PRINT-READABLY* :HAS-METHOD :SAVE SEND FORMAT ERROR :HAS-SLOT ADDRESS-OF) 0 NIL) *OBJECT* BYTE-CODE-CLOSE ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:PRINT) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Method args: (sym &optional val)
Sets and retrieves value of slot named SYM. Sugnals an error if slot
does not exist." :SLOT-VALUE #K(#(77 1 3 1 1 1 0 2 64 3 5 21 2 1 2 3 0 3 6 1 3 0 4 6 21 0 4 5 5 63 2 6 0 62 2 0 57 0) #(0 16 21 24 29 33) #(NIL #(%NOT-SUPPLIED)) 0 NIL) *OBJECT* BYTE-CODE-CLOSE ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:SLOT-VALUE) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Method args: ()
Returns list of slots available to the object." :SLOT-NAMES #K(#(80 2 0 3 39 0 2 38 1 3 23 2 3 2 1 3 51 1 4 0 23 3 3 2 4 3 25 4 0 2 2 3 80 2 0 1 38 5 2 25 2 0 2 1 2) #(0 32) #(APPEND :PRECEDENCE-LIST SEND MAPCAR APPLY :OWN-SLOTS) 0 NIL) *OBJECT* BYTE-CODE-CLOSE ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:SLOT-NAMES) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Method args: ()
Returns list of method selectors available to object." :METHOD-SELECTORS #K(#(80 2 0 3 39 0 2 38 1 3 23 2 3 2 1 3 51 1 4 0 23 3 3 2 4 3 25 4 0 2 2 3 80 2 0 1 38 5 2 25 2 0 2 1 2) #(0 32) #(APPEND :PRECEDENCE-LIST SEND MAPCAR APPLY :OWN-METHODS) 0 NIL) *OBJECT* BYTE-CODE-CLOSE ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:METHOD-SELECTORS) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :REMOVE #K(#(80 2 0 1 38 0 2 25 1 0 2 1 2) #(0) #(:DISPOSE SEND) 0 NIL) HARDWARE-OBJECT-PROTO BYTE-CODE-CLOSE ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:REMOVE) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :ALLOCATED-P #K(#(80 2 1 0 0 62 2 0 57 0) #(0) #(HARDWARE-ADDRESS) 0 NIL) HARDWARE-OBJECT-PROTO BYTE-CODE-CLOSE ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:ALLOCATED-P) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :ADD-SUBORDINATE #K(#(80 3 1 0 1 62 3 4 23 1 4 2 2 4 63 3 4 0 57 0) #(0) #(SUBORDINATES ADJOIN) 0 NIL) HARDWARE-OBJECT-PROTO BYTE-CODE-CLOSE ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:ADD-SUBORDINATE) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :DELETE-SUBORDINATE #K(#(80 3 1 0 1 62 3 4 23 1 4 2 2 4 63 3 4 0 57 0) #(0) #(SUBORDINATES REMOVE) 0 NIL) HARDWARE-OBJECT-PROTO BYTE-CODE-CLOSE ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:DELETE-SUBORDINATE) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :CLOBBER #K(#(80 2 2 0 1 3 62 3 4 21 0 1 4 4 62 3 4 16 4 5 21 1 2 3 4 38 2 6 23 3 0 2 5 6 17 4 4 16 4 5 21 1 2 3 4 11 0 2 11 0 2) #(0 14 25 45 48) #(NIL SUBORDINATES :REMOVE SEND) 0 NIL) HARDWARE-OBJECT-PROTO BYTE-CODE-CLOSE ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:CLOBBER) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #(ACTIVE-WINDOWS EXPORT) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 0 25 3 0 3 3 2 1) #(0) #("Args: ()
Returns list of active windows." FUNCTION-DOCUMENTATION ACTIVE-WINDOWS %SET-GET) 0 NIL) #K(#(80 1 2 0 1 1 23 2 3 1 2 25 3 0 2 1 3) #(0) #(ACTIVE-WINDOWS #K(#(80 1 0 2 39 0 1 38 1 2 23 2 1 2 1 2 51 1 2 0 25 3 0 2 2 1 80 2 0 1 38 4 2 25 5 0 2 1 2) #(0 26) #(THIRD *HARDWARE-OBJECTS* MAPCAR REMOVE-IF-NOT WINDOW-PROTO KIND-OF-P) 0 NIL) BYTE-CODE-CLOSE INSTALL-FUNCTION) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 2 0 1 2 38 2 3 38 3 4 25 4 0 4 3 4 2 1) #(0) #(MODELESS TYPE DIALOG-PROTO :SLOT-VALUE SEND) 0 NIL)
#K(#(80 1 2 0 1 2 38 2 3 38 3 4 25 4 0 4 3 4 2 1) #(0) #(T GO-AWAY DIALOG-PROTO :SLOT-VALUE SEND) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :ITEMS #K(#(80 2 1 0 0 62 2 0 57 0) #(0) #(ITEMS) 0 NIL) DIALOG-PROTO BYTE-CODE-CLOSE ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:ITEMS) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :DIALOG #K(#(80 2 1 0 0 62 2 0 57 0) #(0) #(DIALOG) 0 NIL) DIALOG-ITEM-PROTO BYTE-CODE-CLOSE ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:DIALOG) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 2 0 1 4 38 2 3 39 3 4 23 4 5 1 3 21 0 1 2 5 0 3 5 1 3 23 5 5 1 3 23 6 3 2 4 5 0 2 4 16 4 5 21 1 4 5 4 38 7 6 23 8 0 3 3 6 5 17 4 4 16 4 5 21 1 4 5 4 38 9 6 23 8 0 4 3 6 1 2 23 10 0 2 1 3 11 0 1) #(0 22 27 32 49 70) #(EDIT-TEXT-ITEM-PROTO NIL TEXT-ITEM-PROTO MAKE-OBJECT LISTP LIST APPLY :ADD-SLOT SEND :MAKE-PROTOTYPE SET) 0 NIL)
#K(#(80 1 2 0 1 2 38 2 3 38 3 4 25 4 0 4 3 4 2 1) #(0) #(T EDITABLE EDIT-TEXT-ITEM-PROTO :SLOT-VALUE SEND) 0 NIL)
#K(#(80 1 3 0 1 2 4 38 3 4 39 4 5 23 5 6 1 4 21 0 1 2 6 0 4 6 1 3 23 6 6 1 4 23 7 4 2 5 6 0 3 5 16 5 6 21 1 4 5 5 38 8 7 23 9 0 3 4 7 6 17 5 5 16 5 6 21 1 4 5 5 38 10 7 23 9 0 4 4 7 2 1 23 11 0 2 2 4 11 0 2) #(0 23 28 33 50 71) #((MODAL-THROW-TARGET) MODAL-DIALOG-PROTO NIL DIALOG-PROTO MAKE-OBJECT LISTP LIST APPLY :ADD-SLOT SEND :MAKE-PROTOTYPE SET) 0 NIL)
#K(#(80 1 2 0 1 2 38 2 3 38 3 4 25 4 0 4 3 4 2 1) #(0) #(MODAL TYPE MODAL-DIALOG-PROTO :SLOT-VALUE SEND) 0 NIL)
#K(#(80 1 2 0 1 2 38 2 3 38 3 4 25 4 0 4 3 4 2 1) #(0) #(NIL GO-AWAY MODAL-DIALOG-PROTO :SLOT-VALUE SEND) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Metod args: (&optional (remove t))
Runs the modal dialog loop until the :modal-dialog-return message
is sent. Returns the argument to :modal-dialog-return. If REMOVE
is not NIL, dialog is sent the :remove message before returning." :MODAL-DIALOG #K(#(77 1 2 1 2 2 0 1 4 62 4 5 21 0 1 2 5 11 0 3 63 4 1 0 38 3 5 23 4 0 2 1 5 56 6 3 5 5 57 0 63 4 3 0 21 0 4 5 2 38 5 6 25 4 5 2 1 6 11 5 3 65 1 7 6 57 5 23 6 7 0 38 7 8 23 4 0 2 7 8 1 8) #(0 17 20 40 49 58 61 67 67) #(NIL MODAL-THROW-TARGET #(T) :SHOW-WINDOW SEND :REMOVE CALL-NEXT-METHOD :DO-ACTION) 0 NIL) MODAL-DIALOG-PROTO BYTE-CODE-CLOSE ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:MODAL-DIALOG) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Method Args: (value)
Ends modal dialog loop and has :modal-dialog return VALUE." :MODAL-DIALOG-RETURN #K(#(80 3 2 0 1 1 62 4 5 21 0 1 2 5 12 1 2 66 5 11 0 3) #(0 14 19) #(NIL MODAL-THROW-TARGET) 0 NIL) MODAL-DIALOG-PROTO BYTE-CODE-CLOSE ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:MODAL-DIALOG-RETURN) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 3 0 1 0 4 38 2 4 39 3 5 23 4 6 1 4 21 0 1 2 6 0 4 6 1 3 23 5 6 1 4 23 6 4 2 5 6 0 3 5 16 5 6 21 1 4 5 5 38 7 7 23 8 0 3 4 7 6 17 5 5 16 5 6 21 1 4 5 5 38 9 7 23 8 0 4 4 7 2 1 23 10 0 2 2 4 11 0 2) #(0 23 28 33 50 71) #(NIL MODAL-BUTTON-PROTO BUTTON-ITEM-PROTO MAKE-OBJECT LISTP LIST APPLY :ADD-SLOT SEND :MAKE-PROTOTYPE SET) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :DO-ACTION #K(#(80 2 3 0 1 2 4 62 4 5 62 3 6 21 0 1 5 6 38 3 7 21 0 2 3 5 31 5 8 0 1 4 0 2 8 25 4 0 3 6 7 8 11 0 2) #(0 18 26 32 35 42) #(NIL DIALOG ACTION :MODAL-DIALOG-RETURN SEND) 0 NIL) MODAL-BUTTON-PROTO BYTE-CODE-CLOSE ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:DO-ACTION) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 4 0 1 2 3 4 38 4 5 39 5 6 23 6 7 1 5 21 0 1 2 7 0 5 7 1 3 23 7 7 1 5 23 8 5 2 6 7 0 4 6 16 6 7 21 1 4 5 6 38 9 8 23 10 0 3 5 8 7 17 6 6 16 6 7 21 1 4 5 6 38 11 8 23 10 0 4 5 8 3 4 38 12 8 23 10 0 4 5 8 2 1 23 13 0 2 3 5 11 0 3) #(0 24 29 34 51 72) #("Disabled separator line" PROTO DASH-ITEM-PROTO NIL MENU-ITEM-PROTO MAKE-OBJECT LISTP LIST APPLY :ADD-SLOT SEND :MAKE-PROTOTYPE :DOCUMENTATION SET) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :ISNEW #K(#(80 2 2 0 1 1 38 2 4 25 3 0 3 3 4 2) #(0) #(NIL "-" :ENABLED CALL-NEXT-METHOD) 0 NIL) DASH-ITEM-PROTO BYTE-CODE-CLOSE ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:ISNEW) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Method args: ()
Returns menu if item is installed, NIL otherwise." :MENU #K(#(80 2 1 0 0 62 2 0 57 0) #(0) #(MENU) 0 NIL) MENU-ITEM-PROTO BYTE-CODE-CLOSE ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:MENU) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :PRINT #K(#(77 1 2 1 3 3 0 1 2 3 23 4 6 1 1 62 5 7 62 4 8 25 5 0 5 2 3 6 7 8) #(0) #("#<Object: ~d, prototype = ~a, title = ~s>" TITLE PROTO-NAME #(T) ADDRESS-OF FORMAT) 0 NIL) MENU-PROTO BYTE-CODE-CLOSE ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:PRINT) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :PRINT #K(#(77 1 2 1 3 3 0 1 2 3 23 4 6 1 1 62 5 7 62 4 8 25 5 0 5 2 3 6 7 8) #(0) #("#<Object: ~d, prototype = ~a, title = ~s>" TITLE PROTO-NAME #(NIL) ADDRESS-OF FORMAT) 0 NIL) MENU-ITEM-PROTO BYTE-CODE-CLOSE ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:PRINT) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Method args: ()
Erases the entire window canvas." :ERASE-WINDOW #K(#(80 2 1 0 3 38 1 3 23 2 3 2 1 3 38 3 4 23 2 4 2 1 4 38 4 5 25 2 0 6 1 5 2 2 3 4) #(0) #(0 :CANVAS-WIDTH SEND :CANVAS-HEIGHT :ERASE-RECT) 0 NIL) GRAPH-WINDOW-PROTO BYTE-CODE-CLOSE ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:ERASE-WINDOW) 0 NIL)) EVAL) 0 NIL)
