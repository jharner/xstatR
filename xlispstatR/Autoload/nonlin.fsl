(XLISP::CHECK-FSL-VERSION 1 4)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #("nonlin" PROVIDE) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #("regress" REQUIRE) 0 NIL)
#K(#(80 1 3 0 1 2 4 38 3 4 39 4 5 23 5 6 1 4 21 0 1 2 6 0 4 6 1 3 23 6 6 1 4 23 7 4 2 5 6 0 3 5 16 5 6 21 1 4 5 5 38 8 7 23 9 0 3 4 7 6 17 5 5 16 5 6 21 1 4 5 5 38 10 7 23 9 0 4 4 7 2 1 23 11 0 2 2 4 11 0 2) #(0 23 28 33 50 71) #((MEAN-FUNCTION THETA-HAT EPSILON COUNT-LIMIT VERBOSE) NREG-MODEL-PROTO NIL REGRESSION-MODEL-PROTO MAKE-OBJECT LISTP LIST APPLY :ADD-SLOT SEND :MAKE-PROTOTYPE SET) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 0 25 3 0 3 3 2 1) #(0) #("Args: (mean-function y theta &key (epsilon .0001) (count-limit 20) 
                      (print t) parameter-names response-name case-labels
                      weights included (verbose print))
Fits nonlinear regression model with MEAN-FUNCTION and response Y using initial
parameter guess THETA. Returns model object." FUNCTION-DOCUMENTATION NREG-MODEL %SET-GET) 0 NIL) #K(#(80 1 2 0 1 1 23 2 3 1 2 25 3 0 2 1 3) #(0) #(NREG-MODEL #K(#(77 3 4 0 0 0 2 1 1 0 3 21 2 1 2 12 0 12 14 1 3 0 5 14 38 3 15 38 4 16 23 5 15 2 15 16 38 6 16 23 5 0 3 15 16 1 38 7 16 23 5 0 3 15 16 2 38 8 16 23 5 0 3 15 16 3 38 9 16 23 5 0 3 15 16 4 38 10 16 23 5 0 3 15 16 6 38 11 16 23 5 0 3 15 16 7 38 12 16 23 5 0 3 15 16 8 38 13 16 23 5 0 3 15 16 9 38 14 16 23 5 0 3 15 16 10 38 15 16 23 5 0 3 15 16 11 38 16 16 23 5 0 3 15 16 14 21 0 4 5 5 38 17 16 23 5 0 2 15 16 11 0 15) #(0 16 21 24 151 160) #(NIL (1.0E-4 T 20 NIL NIL NIL NIL NIL %NOT-SUPPLIED) (:EPSILON :PRINT :COUNT-LIMIT :PARAMETER-NAMES :RESPONSE-NAME :CASE-LABELS :WEIGHTS :INCLUDED :VERBOSE) NREG-MODEL-PROTO :NEW SEND :MEAN-FUNCTION :Y :NEW-INITIAL-GUESS :EPSILON :COUNT-LIMIT :PARAMETER-NAMES :RESPONSE-NAME :CASE-LABELS :WEIGHTS :INCLUDED :VERBOSE :DISPLAY) 0 NIL) BYTE-CODE-CLOSE XLISP::INSTALL-FUNCTION) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Message args: ()
Returns an expression that will reconstruct the regression model." :SAVE #K(#(80 2 10 0 1 2 3 4 5 6 7 8 9 21 23 10 12 1 11 23 10 13 1 10 38 11 14 23 12 14 2 1 14 23 10 14 1 14 23 13 13 2 13 14 23 10 13 1 13 23 10 14 1 10 38 14 15 23 12 15 2 1 15 23 10 15 1 15 23 13 14 2 14 15 23 10 14 1 14 23 10 15 1 10 38 15 16 23 12 16 2 1 16 23 10 16 1 16 23 13 15 2 15 16 23 10 15 1 15 23 10 16 1 9 23 10 17 1 10 38 7 18 23 12 18 2 1 18 23 10 18 1 18 23 13 17 2 17 18 23 10 17 1 17 23 10 18 1 8 23 10 19 1 10 38 6 20 23 12 20 2 1 20 23 10 20 1 20 23 13 19 2 19 20 23 10 19 1 19 23 10 20 1 7 23 10 21 1 10 38 5 22 23 12 22 2 1 22 23 10 22 1 22 23 13 21 2 21 22 23 10 21 1 21 23 10 22 1 6 23 10 23 1 10 38 4 24 23 12 24 2 1 24 23 10 24 1 24 23 13 23 2 23 24 23 10 23 1 23 23 10 24 1 5 23 10 25 1 10 38 3 26 23 12 26 2 1 26 23 10 26 1 26 23 13 25 2 25 26 23 10 25 1 25 23 10 26 1 4 23 10 27 1 10 38 2 28 23 12 28 2 1 28 23 10 28 1 28 23 13 27 2 27 28 23 10 27 1 27 23 10 28 1 3 23 10 29 1 10 38 1 30 23 12 30 2 1 30 23 10 30 1 30 23 13 29 2 29 30 23 10 29 1 29 23 10 30 1 2 23 10 31 1 10 38 0 32 23 12 32 2 1 32 23 10 32 1 32 23 13 31 2 31 32 23 10 31 1 31 25 13 0 20 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31) #(0) #(:VERBOSE :INCLUDED :WEIGHTS :CASE-LABELS :RESPONSE-NAME :PREDICTOR-NAMES :COUNT-LIMIT :EPSILON QUOTE NREG-MODEL LIST :MEAN-FUNCTION SEND APPEND :Y :COEF-ESTIMATES) 0 NIL) NREG-MODEL-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:SAVE) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Message args: ()
Recomputes the estimates. For internal use by other messages" :COMPUTE #K(#(80 2 8 0 1 2 3 4 5 6 7 9 38 8 10 23 9 10 2 1 10 38 10 11 23 9 11 2 1 11 38 11 12 23 9 12 2 1 12 23 12 12 3 12 9 8 21 0 1 2 11 2 42 12 11 13 1 3 0 12 13 38 13 14 23 9 14 2 1 14 62 7 15 38 14 16 23 9 16 2 1 16 38 15 17 23 9 17 2 1 17 38 16 18 23 9 18 2 1 18 23 17 13 7 14 10 15 16 17 13 18 63 7 13 0 62 6 13 62 7 14 23 18 14 1 14 23 19 13 2 13 14 62 7 14 31 13 13 1 14 63 5 13 0 63 4 3 0 23 20 0 0 38 21 13 23 9 13 2 1 13 23 22 10 3 12 13 13 23 23 10 1 10 63 2 10 0 57 0) #(0 51 58 61) #(RESIDUAL-SUM-OF-SQUARES NIL INTERCEPT X MEAN-FUNCTION THETA-HAT 0 1 :Y SEND :WEIGHTS :INCLUDED IF-ELSE :MEAN-FUNCTION :EPSILON :COUNT-LIMIT :VERBOSE NLREG LENGTH MAKE-JACOBIAN CALL-NEXT-METHOD :RESIDUALS * SUM) 0 NIL) NREG-MODEL-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:COMPUTE) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Message args: (guess)
Sets a new initial uess for parmeters." :NEW-INITIAL-GUESS #K(#(80 3 2 0 1 1 63 4 2 0 38 2 5 25 3 0 3 1 5 3) #(0) #(T THETA-HAT :NEEDS-COMPUTING SEND) 0 NIL) NREG-MODEL-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:NEW-INITIAL-GUESS) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Message args: ()
Returns current parameter estimate." :THETA-HAT #K(#(80 2 3 0 1 2 2 38 3 5 23 4 5 2 1 5 21 0 1 2 5 38 5 6 23 4 0 2 1 6 62 4 5 25 6 0 2 5 3) #(0 21 30) #(NIL LIST THETA-HAT :NEEDS-COMPUTING SEND :COMPUTE COERCE) 0 NIL) NREG-MODEL-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:THETA-HAT) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Message args: (&optional f)
With no argument returns the mean function as supplied to m. With an 
argument F sets the mean function of m to F and recomputes the
estimates." :MEAN-FUNCTION #K(#(77 1 2 1 3 3 0 1 2 2 21 0 1 2 2 23 4 6 1 2 1 3 0 4 6 21 0 4 5 6 63 5 2 0 38 5 7 23 6 0 3 1 7 3 62 5 0 57 0) #(0 15 22 25 30 44) #(T NIL MEAN-FUNCTION #(NIL) FUNCTIONP :NEEDS-COMPUTING SEND) 0 NIL) NREG-MODEL-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:MEAN-FUNCTION) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Message args: (&optional eps)
With no argument returns the tolerance as supplied to m. With an argument
EPS sets the tolerance of m to EPS and recomputes the estimates." :EPSILON #K(#(77 1 2 1 3 3 0 1 2 2 21 0 1 2 2 23 4 6 1 2 1 3 0 4 6 21 0 4 5 6 63 5 2 0 38 5 7 23 6 0 3 1 7 3 62 5 0 57 0) #(0 15 22 25 30 44) #(T NIL EPSILON #(NIL) NUMBERP :NEEDS-COMPUTING SEND) 0 NIL) NREG-MODEL-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:EPSILON) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Message args: (&optional new-count)
With no argument returns the iteration count limit as supplied to m. With
an argument COUNT sets the limit to COUNT and recomputes the
estimates." :COUNT-LIMIT #K(#(77 1 2 1 3 3 0 1 2 2 21 0 1 2 2 23 4 6 1 2 1 3 0 4 6 21 0 4 5 6 63 5 2 0 38 5 7 23 6 0 3 1 7 3 62 5 0 57 0) #(0 15 22 25 30 44) #(T NIL COUNT-LIMIT #(NIL) NUMBERP :NEEDS-COMPUTING SEND) 0 NIL) NREG-MODEL-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:COUNT-LIMIT) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Method args: (&optional names)
Sets or returns parameter names." :PARAMETER-NAMES #K(#(77 1 2 1 5 5 0 1 2 3 4 5 64 2 8 21 2 1 2 2 0 2 9 1 3 0 3 9 21 0 4 5 8 63 7 9 0 62 7 8 62 6 9 23 6 9 1 9 21 0 6 7 8 23 6 10 1 8 3 61 9 10 10 1 8 0 3 10 21 0 10 9 10 2 45 9 5 11 23 7 11 2 4 11 51 11 12 0 23 8 11 2 12 11 63 7 11 0 62 7 0 57 0 80 2 2 9 0 0 25 10 0 3 3 2 1) #(0 20 25 28 33 37 53 65 68 73 98 103) #(NIL 0 1 THETA-HAT PREDICTOR-NAMES #(%NOT-SUPPLIED) LENGTH ISEQ MAPCAR "Parameter ~a" FORMAT) 0 NIL) NREG-MODEL-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:PARAMETER-NAMES) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Method args: (&optional val)
Sets or retrieves verbose setting. If T iteration info is printed during
optimization." :VERBOSE #K(#(77 1 2 1 2 2 0 1 2 64 2 5 21 2 1 2 2 0 2 6 1 3 0 3 6 21 0 4 5 5 63 4 6 0 62 4 0 57 0) #(0 17 22 25 30 34) #(NIL VERBOSE #(%NOT-SUPPLIED)) 0 NIL) NREG-MODEL-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:VERBOSE) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Message args: ()
Returns the Jacobian matrix at theta-hat." :X #K(#(80 2 0 0 25 0 0 0) #(0) #(CALL-NEXT-METHOD) 0 NIL) NREG-MODEL-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:X) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Message args: ()
Always returns nil. (For compatibility with linear regression.)" :INTERCEPT #K(#(77 2 2 0 1 0 0 11 0 3) #(0) #(NIL) 0 NIL) NREG-MODEL-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:INTERCEPT) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Message args: ()
Returns the fitted values for the model." :FIT-VALUES #K(#(80 2 1 0 2 38 1 3 23 2 3 2 1 3 38 3 4 23 2 4 2 1 4 31 3 3 1 4 25 4 0 2 3 2) #(0) #(LIST :MEAN-FUNCTION SEND :THETA-HAT COERCE) 0 NIL) NREG-MODEL-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:FIT-VALUES) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Message args: (&optional guess)
With no argument returns the current parameter estimate. With an 
argument GUESS takes it as a new initial guess and recomputes
the estimates." :COEF-ESTIMATES #K(#(77 1 2 1 1 1 0 1 21 0 1 2 2 38 2 4 23 3 0 3 1 4 2 38 4 4 25 3 0 2 1 4) #(0 13 23) #(NIL #(NIL) :NEW-INITIAL-GUESS SEND :THETA-HAT) 0 NIL) NREG-MODEL-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:COEF-ESTIMATES) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :PREDICTOR-NAMES #K(#(80 2 0 1 38 0 2 25 1 0 2 1 2) #(0) #(:PARAMETER-NAMES SEND) 0 NIL) NREG-MODEL-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:PREDICTOR-NAMES) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 0 25 3 0 3 3 2 1) #(0) #("Args: (x y &key (intercept T) weights)
Returns the coefficients of the regression of the sequence Y on the columns of
the matrix X." FUNCTION-DOCUMENTATION REGRESSION-COEFFICIENTS %SET-GET) 0 NIL) #K(#(80 1 2 0 1 1 23 2 3 1 2 25 3 0 2 1 3) #(0) #(REGRESSION-COEFFICIENTS #K(#(77 3 3 0 0 0 4 3 3 0 1 2 5 21 0 1 2 4 23 5 8 3 1 2 4 1 3 23 5 8 2 1 2 23 6 9 2 1 7 21 0 4 5 3 23 7 10 2 7 9 23 8 10 2 8 10 16 10 10 61 112 9 11 23 7 12 2 5 9 23 9 8 3 10 11 12 1 6 23 7 10 2 5 9 23 8 10 2 8 10 16 10 10 61 112 9 11 23 7 12 2 7 9 23 9 8 3 10 11 12 23 10 8 1 8 25 11 0 2 8 6) #(0 18 27 33 44 78 110) #(0 VECTOR 1 (T NIL) (:INTERCEPT :WEIGHTS) MAKE-SWEEP-MATRIX ARRAY-DIMENSION ISEQ SWEEP-OPERATOR SELECT COMPOUND-DATA-SEQ COERCE) 0 NIL) BYTE-CODE-CLOSE XLISP::INSTALL-FUNCTION) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 0 25 3 0 3 3 2 1) #(0) #("Args: (mean-function jacobian y initial-beta 
        epsilon count-limit weights verbose)
MEAN-FUNCTION returns the mean response vector for a given parameter vector.
JACOBIAN returns the jacobian of MEAN-FUNCTION at a given parameter vector.
Y is the observed response vector. Returns the estimated parameter vector 
obtained by a Gauss-Newton algorithm with backtracking that continues until
the COUNT-LIMIT is reached or no component of the parameter vector changes
by more than EPSILON." FUNCTION-DOCUMENTATION NLREG1 %SET-GET) 0 NIL) #K(#(80 1 2 0 1 1 23 2 3 1 2 25 3 0 2 1 3) #(0) #(NLREG1 #K(#(80 9 8 0 1 2 3 4 5 6 7 10 31 2 17 1 4 31 1 18 1 4 2 45 3 18 18 38 8 19 38 9 20 23 10 17 6 17 18 19 16 20 7 0 4 18 27 23 19 4 7 3 1 18 0 15 20 3 62 20 6 21 21 0 2 1 21 23 11 22 1 17 23 12 22 1 22 3 62 5 22 21 21 0 17 3 21 21 0 4 5 8 23 13 0 3 14 9 19 31 2 21 1 18 31 1 22 1 18 2 45 3 22 22 38 8 23 38 9 24 23 10 17 6 21 22 23 16 24 7 0 18 21 0 17 22 0 19 23 0 12 24 2 43 21 22 25 27 23 25 4 7 3 1 25 3 60 25 23 26 21 0 7 6 26 3 60 24 11 26 21 0 11 8 26 2 47 24 10 24 2 42 24 22 26 2 43 21 26 26 27 23 25 4 7 3 1 26 3 60 25 23 26 21 0 10 9 26 3 60 24 11 26 21 0 11 8 26 37 71 12 13 24 11 2 42 24 22 26 2 43 21 26 18 1 14 0 21 18 27 23 19 4 7 3 1 18 61 112 20 20 3 62 20 6 21 21 0 16 15 21 23 11 22 1 17 23 12 22 1 22 3 62 5 22 21 21 0 17 3 21 21 0 18 19 8 3 62 20 6 21 1 20 0 16 21 21 0 21 22 21 23 13 0 2 14 13 11 0 18 80 5 0 1 31 3 5 1 4 2 45 2 5 5 21 0 24 25 1 23 14 5 3 5 5 1 1 26 2 42 5 5 5 25 15 0 1 5) #(0 67 82 87 92 99 165 170 175 208 213 218 224 236 239 261 276 281 286 293 296 301 307 310 329 338 343) #("Residual sum of squares: ~,6g~%" 2 1.0E-4 1 "Iteration limit exceeded.~%" T 0 NIL :INTERCEPT :WEIGHTS REGRESSION-COEFFICIENTS ABS MAX FORMAT * SUM) 0 NIL) BYTE-CODE-CLOSE XLISP::INSTALL-FUNCTION) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 0 25 3 0 3 3 2 1) #(0) #("Args: (f n)
F is a function of an N-vector. Returns a function that approximates the
jacobian function iof F by a symmetric difference." FUNCTION-DOCUMENTATION MAKE-JACOBIAN %SET-GET) 0 NIL) #K(#(80 1 2 0 1 1 23 2 3 1 2 25 3 0 2 1 3) #(0) #(MAKE-JACOBIAN #K(#(80 3 1 0 1 23 1 4 1 2 23 2 4 1 4 2 42 3 4 4 51 3 4 2 1 4 11 0 4 80 3 0 0 2 45 1 2 0 57 0 80 3 0 0 2 43 1 2 0 57 0 80 4 1 3 5 51 2 5 1 3 23 4 5 2 5 2 51 1 6 1 3 23 4 6 2 6 2 39 5 7 23 4 8 2 1 5 23 4 9 2 1 6 2 45 8 9 8 2 47 8 4 8 25 6 0 2 7 8) #(0 29 40 51) #(1.0E-4 IDENTITY-MATRIX COLUMN-LIST 2.0E-4 MAPCAR BIND-COLUMNS APPLY) 0 NIL) BYTE-CODE-CLOSE XLISP::INSTALL-FUNCTION) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 0 25 3 0 3 3 2 1) #(0) #("Args: (mean-function y guess &optional 
        (epsilon .0001) (count-limit 20) weights verbose)
MEAN-FUNCTION returns the mean response vector for a given parameter vector.
Y is the observed response vector. Returns the estimated parameter vector 
obtained by a Gauss-Newton algorithm that continues until the ITERATION-LIMIT
is reached or no component of the parameter vector changes by more than
EPSILON. The jacobian of MEAN-FUNCTION is approximated by a symmetric difference." FUNCTION-DOCUMENTATION NLREG %SET-GET) 0 NIL) #K(#(80 1 2 0 1 1 23 2 3 1 2 25 3 0 2 1 3) #(0) #(NLREG #K(#(77 1 4 4 0 0 1 23 1 8 1 3 23 2 8 2 1 8 25 3 0 8 1 8 2 3 4 5 6 7) #(0) #(#(1.0E-4 20 NIL NIL) LENGTH MAKE-JACOBIAN NLREG1) 0 NIL) BYTE-CODE-CLOSE XLISP::INSTALL-FUNCTION) 0 NIL)) EVAL) 0 NIL)
