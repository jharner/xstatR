(XLISP::CHECK-FSL-VERSION 1 4)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #("maximize" REQUIRE) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #("bayes" PROVIDE) 0 NIL)
#K(#(80 1 3 0 1 2 4 39 3 4 23 4 5 1 3 21 0 1 2 5 0 3 5 1 3 23 5 5 1 3 23 6 4 2 4 5 0 3 5 16 5 6 21 1 4 5 5 38 7 7 23 8 0 3 4 7 6 17 5 5 16 5 6 21 1 4 5 5 38 9 7 23 8 0 4 4 7 2 1 23 10 0 2 2 4 11 0 2) #(0 20 25 30 47 68) #((F H NUM-DERIVS) C2-FUNCTION-PROTO NIL MAKE-OBJECT LISTP LIST APPLY :ADD-SLOT SEND :MAKE-PROTOTYPE SET) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :ISNEW #K(#(77 1 3 2 3 3 0 1 2 1 63 7 2 0 23 4 8 1 3 21 0 1 2 8 23 5 8 2 3 3 1 3 0 3 8 63 6 8 0 63 5 4 0 57 0) #(0 24 32 35) #(NUM-DERIVS H F #(0.001 0) NUMBERP LIST) 0 NIL) C2-FUNCTION-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:ISNEW) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :F #K(#(77 1 2 1 2 2 0 1 0 21 0 1 2 2 63 4 2 0 62 4 0 57 0) #(0 14 18) #(NIL F #(NIL)) 0 NIL) C2-FUNCTION-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:F) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :GRAD-H #K(#(80 2 1 0 1 62 2 3 16 3 0 57 0) #(0) #(H) 0 NIL) C2-FUNCTION-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:GRAD-H) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :HESS-H #K(#(80 2 1 0 1 62 2 3 71 2 2 3 0 57 0) #(0) #(H) 0 NIL) C2-FUNCTION-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:HESS-H) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :NUM-DERIVS #K(#(80 2 1 0 0 62 2 0 57 0) #(0) #(NUM-DERIVS) 0 NIL) C2-FUNCTION-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:NUM-DERIVS) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :VALUE #K(#(80 3 0 2 38 0 3 23 1 3 2 1 3 23 2 4 1 3 21 0 1 2 4 38 3 4 25 1 0 3 3 4 2 31 3 3 1 2 21 1 3 4 3 16 3 0 57 0 11 0 3) #(0 23 33 43 48) #(:F SEND OBJECTP :VALUE) 0 NIL) C2-FUNCTION-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:VALUE) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :GRADIENT #K(#(77 1 3 1 1 1 0 3 21 2 1 2 3 0 3 5 1 3 38 2 5 23 3 5 2 1 5 38 4 6 23 3 6 2 1 6 23 5 7 1 6 21 0 4 5 7 38 6 7 25 3 0 4 6 7 2 5 25 7 0 4 6 2 4 5) #(0 13 18 27 46 57) #(NIL #(%NOT-SUPPLIED) :GRAD-H SEND :F OBJECTP :GRADIENT NUMGRAD) 0 NIL) C2-FUNCTION-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:GRADIENT) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :HESSIAN #K(#(77 1 3 1 1 1 0 3 21 2 1 2 3 0 3 5 1 3 38 2 5 23 3 5 2 1 5 38 4 6 23 3 6 2 1 6 23 5 7 1 6 21 0 4 5 7 38 6 7 25 3 0 4 6 7 2 5 25 7 0 4 6 2 4 5) #(0 13 18 27 46 57) #(NIL #(%NOT-SUPPLIED) :HESS-H SEND :F OBJECTP :HESSIAN NUMHESS) 0 NIL) C2-FUNCTION-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:HESSIAN) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :VALS #K(#(77 1 3 1 1 1 0 5 21 2 1 2 3 0 3 5 1 3 38 2 5 23 3 5 2 1 5 38 4 6 23 3 6 2 1 6 23 5 7 1 6 21 0 4 5 7 38 6 7 25 3 0 4 6 7 2 5 31 6 6 1 2 21 1 6 9 6 23 7 7 1 6 37 61 7 8 7 4 11 0 6 16 6 7 71 2 2 6 8 38 8 9 23 3 9 4 1 9 2 5 25 9 0 3 7 8 9 38 10 7 23 3 7 4 1 7 2 5 38 8 8 23 3 8 4 1 8 2 5 25 9 0 3 6 7 8) #(0 13 18 27 46 57 67 78 81 107) #(3 #(%NOT-SUPPLIED) :HESS-H SEND :F OBJECTP :VALS LENGTH :HESSIAN LIST :GRADIENT) 0 NIL) C2-FUNCTION-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:VALS) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :VALS #K(#(77 1 3 1 2 2 0 1 3 21 2 1 2 3 0 3 6 1 3 38 3 6 23 4 6 2 1 6 38 5 7 23 4 7 2 1 7 23 6 8 1 7 21 0 4 5 8 38 7 8 25 4 0 4 7 8 2 6 25 8 0 5 7 2 5 6 4) #(0 14 19 28 47 58) #(T NIL #(%NOT-SUPPLIED) :HESS-H SEND :F OBJECTP :VALS NUMHESS) 0 NIL) C2-FUNCTION-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:VALS) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 3 0 1 2 4 38 3 4 39 4 5 23 5 6 1 4 21 0 1 2 6 0 4 6 1 3 23 6 6 1 4 23 7 4 2 5 6 0 3 5 16 5 6 21 1 4 5 5 38 8 7 23 9 0 3 4 7 6 17 5 5 16 5 6 21 1 4 5 5 38 10 7 23 9 0 4 4 7 2 1 23 11 0 2 2 4 11 0 2) #(0 23 28 33 50 71) #((SCALING) SCALED-C2-FUNCTION-PROTO NIL C2-FUNCTION-PROTO MAKE-OBJECT LISTP LIST APPLY :ADD-SLOT SEND :MAKE-PROTOTYPE SET) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :ISNEW #K(#(77 1 3 5 4 4 0 1 2 3 2 31 2 12 1 3 21 1 1 2 12 23 5 13 1 12 2 45 13 8 12 1 3 0 9 12 37 60 4 5 11 12 23 6 13 1 4 1 6 0 10 13 51 7 13 7 13 6 5 12 2 3 4 25 7 0 3 13 7 12 80 9 3 8 2 9 4 23 10 12 4 7 8 6 11 31 5 12 1 12 21 0 8 14 12 60 4 9 13 12 11 10 9 11 0 10 16 12 13 2 45 13 3 13 2 47 13 2 13 71 2 2 12 14 2 47 14 2 14 23 11 14 2 1 14 71 3 4 12 15 2 47 15 2 15 23 11 15 3 1 15 7 25 12 0 3 13 14 15 16 12 13 2 45 13 3 13 2 47 13 2 13 71 2 2 12 14 2 47 14 2 14 23 11 14 2 1 14 25 12 0 2 13 14 16 12 12 2 45 12 3 12 2 47 12 2 0 57 0 2 45 12 3 12 2 47 12 2 0 57 0 11 0 10) #(0 21 33 36 42 49 52 70 95 103 106 159 194 209 221) #(1 -1 NIL 0 #(NIL NIL 0 1 0.001) LENGTH TRANSPOSE CALL-NEXT-METHOD #(-1 0 1 2) T AX+Y MATMULT LIST) 0 NIL) SCALED-C2-FUNCTION-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:ISNEW) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 3 0 1 2 4 38 3 4 39 4 5 23 5 6 1 4 21 0 1 2 6 0 4 6 1 3 23 6 6 1 4 23 7 4 2 5 6 0 3 5 16 5 6 21 1 4 5 5 38 8 7 23 9 0 3 4 7 6 17 5 5 16 5 6 21 1 4 5 5 38 10 7 23 9 0 4 4 7 2 1 23 11 0 2 2 4 11 0 2) #(0 23 28 33 50 71) #((TILT EXPTILT) TILT-FUNCTION-PROTO NIL C2-FUNCTION-PROTO MAKE-OBJECT LISTP LIST APPLY :ADD-SLOT SEND :MAKE-PROTOTYPE SET) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :ISNEW #K(#(77 1 2 3 3 3 0 1 2 0 23 4 0 2 2 4 63 7 6 0 63 5 3 0 57 0) #(0) #(TILT T EXPTILT #(NIL 0.1 0.001) CALL-NEXT-METHOD) 0 NIL) TILT-FUNCTION-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:ISNEW) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :TILT #K(#(77 1 2 1 2 2 0 1 0 21 0 1 2 2 63 4 2 0 62 4 0 57 0) #(0 14 18) #(NIL TILT #(NIL)) 0 NIL) TILT-FUNCTION-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:TILT) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :EXPTILT #K(#(77 1 2 1 2 2 0 1 2 64 2 5 21 2 1 2 2 0 2 6 1 3 0 3 6 21 0 4 5 5 63 4 6 0 62 4 0 57 0) #(0 17 22 25 30 34) #(NIL EXPTILT #(%NOT-SUPPLIED)) 0 NIL) TILT-FUNCTION-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:EXPTILT) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :VALUE #K(#(80 3 0 6 38 0 3 23 1 3 2 1 3 38 2 4 23 1 4 2 1 4 38 3 5 23 1 5 2 1 5 51 4 6 2 5 2 21 1 1 2 3 39 4 7 23 5 8 2 6 3 23 6 5 2 7 8 1 3 27 4 5 3 5 2 3 2 42 4 5 0 57 0 80 4 0 1 38 7 4 23 1 4 3 3 4 2 21 0 5 6 1 11 0 4 25 8 0 1 4) #(0 42 59 66 73 92 95) #(:F SEND :TILT :EXPTILT + MAPCAR APPLY :VALUE LOG) 0 NIL) TILT-FUNCTION-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:VALUE) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :GRADIENT #K(#(77 1 3 1 0 0 7 21 2 1 2 3 0 3 4 1 3 38 1 4 23 2 4 2 1 4 38 3 5 23 2 5 2 1 5 38 4 6 23 2 6 2 1 6 38 5 7 23 2 7 2 1 7 51 7 8 3 4 2 7 21 1 4 5 5 39 6 9 23 7 10 2 8 5 23 8 7 2 9 10 1 6 27 7 7 4 4 2 7 5 2 42 6 7 0 57 0 80 5 0 2 21 0 8 9 3 38 9 5 25 2 0 4 4 5 2 1 38 10 5 23 2 5 3 4 5 2 38 9 6 23 2 6 4 4 6 2 1 2 47 6 5 0 57 0) #(0 12 17 26 65 82 90 97 106 117) #(#(%NOT-SUPPLIED) :GRAD-H SEND :F :TILT :EXPTILT + MAPCAR APPLY :GRADIENT :VALUE) 0 NIL) TILT-FUNCTION-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:GRADIENT) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :HESSIAN #K(#(77 1 3 1 0 0 7 21 2 1 2 3 0 3 4 1 3 38 1 4 23 2 4 2 1 4 38 3 5 23 2 5 2 1 5 38 4 6 23 2 6 2 1 6 38 5 7 23 2 7 2 1 7 51 7 8 3 7 4 2 21 1 4 5 5 39 6 9 23 7 10 2 8 5 23 8 7 2 9 10 1 6 27 7 7 4 7 4 2 5 2 42 6 7 0 57 0 80 5 0 5 38 9 5 23 2 5 4 4 5 3 2 16 5 6 21 0 8 9 1 71 2 2 5 7 1 10 71 2 2 5 7 2 47 7 6 7 21 0 11 12 1 71 3 4 5 8 1 13 71 3 4 5 8 2 47 8 6 8 21 0 14 15 1 11 0 8 23 10 9 2 7 7 2 45 8 9 0 57 0) #(0 12 17 26 65 82 90 97 120 127 137 142 149 159 164 167) #(#(%NOT-SUPPLIED) :HESS-H SEND :F :TILT :EXPTILT + MAPCAR APPLY :VALS OUTER-PRODUCT) 0 NIL) TILT-FUNCTION-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:HESSIAN) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :VALS #K(#(77 1 3 1 0 0 5 21 2 1 2 3 0 3 4 1 3 38 1 4 23 2 4 2 1 4 38 3 5 23 2 5 2 1 5 38 4 6 23 2 6 2 1 6 38 5 7 23 2 7 2 1 7 51 9 8 3 7 4 2 21 1 4 5 5 23 6 7 2 8 5 1 6 27 9 7 4 7 4 2 5 21 1 7 8 5 39 7 8 23 8 7 2 8 7 2 42 6 7 0 57 0 80 5 0 5 38 9 5 23 2 5 4 4 5 3 2 21 0 10 11 1 11 0 5 16 5 6 71 2 2 5 7 2 47 7 6 7 71 3 4 5 8 2 47 8 6 8 23 10 9 2 7 7 2 45 8 9 8 23 11 9 1 6 25 12 0 3 9 7 8) #(0 12 17 26 65 73 81 86 95 102 122 125) #(#(%NOT-SUPPLIED) :HESS-H SEND :F :TILT :EXPTILT MAPCAR + APPLY :VALS OUTER-PRODUCT LOG LIST) 0 NIL) TILT-FUNCTION-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:VALS) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 3 0 1 2 4 38 3 4 39 4 5 23 5 6 1 4 21 0 1 2 6 0 4 6 1 3 23 6 6 1 4 23 7 4 2 5 6 0 3 5 16 5 6 21 1 4 5 5 38 8 7 23 9 0 3 4 7 6 17 5 5 16 5 6 21 1 4 5 5 38 10 7 23 9 0 4 4 7 2 1 23 11 0 2 2 4 11 0 2) #(0 23 28 33 50 71) #((TILT-OBJECT INIT-PARS) SCALED-LOGPOST-PROTO NIL SCALED-C2-FUNCTION-PROTO MAKE-OBJECT LISTP LIST APPLY :ADD-SLOT SEND :MAKE-PROTOTYPE SET) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :ISNEW #K(#(77 1 3 5 3 3 0 1 2 4 23 4 11 1 3 23 5 12 2 10 11 23 5 13 2 10 11 23 6 14 1 11 61 45 14 14 23 7 11 3 12 13 14 23 8 0 6 2 3 4 5 6 7 63 9 11 0 38 9 11 38 10 12 23 11 11 2 11 12 63 8 11 0 57 0) #(0) #(TILT-OBJECT INIT-PARS 0 #(NIL NIL 0 1 0.001) LENGTH REPEAT IDENTITY-MATRIX LIST CALL-NEXT-METHOD TILT-FUNCTION-PROTO :NEW SEND) 0 NIL) SCALED-LOGPOST-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:ISNEW) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :LOG-LAPLACE #K(#(77 1 3 3 1 1 0 6 38 2 7 23 3 7 4 1 7 2 3 38 4 8 23 3 8 4 1 8 7 5 21 0 1 2 2 38 4 9 23 3 9 4 2 9 7 5 1 3 0 6 9 21 0 4 5 2 71 3 4 8 10 71 3 4 9 11 2 43 10 11 10 1 6 71 3 4 8 10 61 45 10 10 23 5 10 1 10 16 10 10 23 6 10 1 10 23 7 10 1 10 23 8 10 1 10 61 45 10 10 21 0 7 8 4 11 0 10 21 0 9 10 2 16 8 11 16 9 12 25 9 0 3 11 12 10 16 8 11 2 43 11 10 0 57 0) #(0 35 48 51 56 73 78 114 117 122 135) #(NIL #(2 NIL 0.1) :TILT-NEWTON SEND :VALS CHOL-DECOMP DIAGONAL LOG SUM +) 0 NIL) SCALED-LOGPOST-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:LOG-LAPLACE) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :TILT-NEWTON #K(#(77 1 3 1 4 4 0 1 2 3 7 62 7 8 16 8 9 71 2 2 8 10 71 3 4 8 11 0 6 12 27 4 13 6 11 10 1 2 9 5 27 3 14 2 9 13 37 71 2 1 12 3 2 43 12 6 12 27 4 13 6 11 10 1 2 14 4 27 3 14 2 14 13 37 71 2 1 12 3 11 0 14 80 3 0 2 71 2 2 2 3 16 2 4 23 5 3 2 3 4 2 45 1 3 0 57 0 80 7 0 2 21 0 5 8 6 21 0 6 8 2 21 0 7 8 1 23 6 7 2 2 1 1 9 38 7 7 23 8 7 3 3 7 5 17 7 7 21 0 10 11 4 38 7 8 23 8 8 3 4 8 5 17 8 8 2 43 7 8 0 57 0 11 0 7) #(0 52 79 82 107 116 121 126 134 147 152 172) #(NIL T 1 INIT-PARS #(2) SOLVE LIST :VALS SEND) 0 NIL) SCALED-LOGPOST-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:TILT-NEWTON) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :TILT-LAPLACE #K(#(77 1 4 4 1 1 0 2 62 8 9 38 2 10 23 3 0 3 9 10 4 38 4 10 23 3 0 3 9 10 2 38 5 10 23 3 0 3 9 10 3 38 6 10 25 3 0 6 1 10 9 5 6 7) #(0) #(TILT-OBJECT #(T NIL NIL NIL) :EXPTILT SEND :F :TILT :LOG-LAPLACE) 0 NIL) SCALED-LOGPOST-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:TILT-LAPLACE) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :TILT-MODE #K(#(77 3 4 0 0 0 2 1 1 0 2 62 6 7 38 3 8 23 4 0 3 7 8 4 38 5 8 23 4 0 3 7 8 2 38 6 8 23 4 0 3 7 8 3 38 7 8 25 4 0 4 1 8 7 5) #(0) #(TILT-OBJECT (T 2) (:EXPTILT :MAXITER) :EXPTILT SEND :F :TILT :TILT-NEWTON) 0 NIL) SCALED-LOGPOST-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:TILT-MODE) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 3 0 1 2 4 39 3 4 23 4 5 1 3 21 0 1 2 5 0 3 5 1 3 23 5 5 1 3 23 6 4 2 4 5 0 3 5 16 5 6 21 1 4 5 5 38 7 7 23 8 0 3 4 7 6 17 5 5 16 5 6 21 1 4 5 5 38 9 7 23 8 0 4 4 7 2 1 23 10 0 2 2 4 11 0 2) #(0 20 25 30 47 68) #((BAYES-INTERNALS) BAYES-MODEL-PROTO NIL MAKE-OBJECT LISTP LIST APPLY :ADD-SLOT SEND :MAKE-PROTOTYPE SET) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :ISNEW #K(#(77 3 4 0 0 0 3 2 2 0 1 1 38 4 11 23 5 0 10 1 11 2 3 4 5 10 10 9 8 21 0 1 2 7 38 6 11 25 5 0 3 1 11 6 11 0 10) #(0 34 44) #(T NIL (NIL 0.001 T T NIL) (:SCALE :DERIVSTEP :VERBOSE :MAXIMIZE :DOMAIN) :SET-BAYES-INTERNALS SEND :MAXIMIZE) 0 NIL) BAYES-MODEL-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:ISNEW) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 0 25 3 0 3 3 2 1) #(0) #("Args: (logpost mode &key scale derivstep (verbose t)
       (quick t) (print t)))
LOGPOST computes the logposterior density. It should return the
function, or a list of the function value and gradient, or a list of
the function value, gradient and Hessian. MODE is an initial guess for
the mode. SCALE and DERIVSTEP are used for numerical derivatives and
scaling. VERBOSE controls printing of iteration information during
optimization, PRINT controls printing of summary information. If QUICK
is T the summary is based on first order approximations." FUNCTION-DOCUMENTATION BAYES-MODEL %SET-GET) 0 NIL) #K(#(80 1 2 0 1 1 23 2 3 1 2 25 3 0 2 1 3) #(0) #(BAYES-MODEL #K(#(77 3 3 0 1 0 2 1 1 0 3 39 3 7 38 4 8 38 5 9 23 6 7 6 7 8 9 1 2 3 21 0 1 2 5 38 7 8 38 8 9 23 3 0 4 7 8 9 4 11 0 7) #(0 35 49) #(NIL (T T) (:QUICK :PRINT) SEND BAYES-MODEL-PROTO :NEW APPLY :DISPLAY :QUICK) 0 NIL) BYTE-CODE-CLOSE XLISP::INSTALL-FUNCTION) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :DISPLAY #K(#(77 3 2 0 0 0 5 4 4 0 1 2 3 5 21 0 1 2 2 38 6 7 1 3 38 7 7 23 8 7 2 1 7 16 7 8 71 2 2 7 9 38 9 10 23 8 10 2 1 10 21 0 4 5 2 23 10 0 2 6 3 1 6 23 10 0 2 6 4 51 7 11 0 23 11 0 4 11 10 8 9 25 10 0 2 6 5 80 4 2 12 3 0 25 10 0 5 5 4 1 2 3) #(0 19 24 27 55 63 69 87) #("~2%First Order Approximations to Posterior Moments:~2%" "~2%Approximate Posterior Moments:~2%" "~%" T (T) (:QUICK) :1STMOMENTS :MOMENTS SEND :PARAMETER-NAMES FORMAT MAPCAR "~a~25t~13,6g~40t(~,6g)~%") 0 NIL) BAYES-MODEL-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:DISPLAY) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :PARAMETER-NAMES #K(#(80 2 2 0 1 2 38 2 4 23 3 4 2 1 4 23 4 4 1 4 2 45 4 3 4 23 5 4 2 2 4 51 1 5 0 25 6 0 2 5 4 80 2 2 7 8 0 25 9 0 3 3 2 1) #(0 41) #(0 1 :MODE SEND LENGTH ISEQ MAPCAR "Parameter ~d" NIL FORMAT) 0 NIL) BAYES-MODEL-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:PARAMETER-NAMES) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :SET-BAYES-INTERNALS #K(#(80 10 1 0 1 23 1 11 8 2 3 4 5 6 7 8 9 63 10 11 0 57 0) #(0) #(BAYES-INTERNALS VECTOR) 0 NIL) BAYES-MODEL-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:SET-BAYES-INTERNALS) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :LOGPOST #K(#(77 1 2 1 4 4 0 1 2 3 2 62 6 7 21 0 1 2 2 23 5 0 3 7 5 2 38 6 8 23 7 0 3 1 8 3 25 8 0 2 7 5) #(0 19 36) #(T NIL 0 BAYES-INTERNALS #(NIL) SET-SELECT :NEEDS-MAXIMIZING SEND SELECT) 0 NIL) BAYES-MODEL-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:LOGPOST) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :DOMAIN #K(#(77 1 2 1 3 3 0 1 2 1 62 5 6 21 0 1 2 2 23 4 0 3 6 4 2 25 5 0 2 6 4) #(0 18 25) #(NIL 7 BAYES-INTERNALS #(NIL) SET-SELECT SELECT) 0 NIL) BAYES-MODEL-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:DOMAIN) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :MODE-VALUES #K(#(77 1 2 3 5 5 0 1 2 3 4 4 62 9 10 21 0 1 2 2 23 6 0 3 10 8 2 23 6 0 3 10 7 3 23 6 0 3 10 6 4 23 7 11 2 10 8 23 7 12 2 10 7 23 7 13 2 10 6 25 8 0 3 11 12 13) #(0 20 41) #(NIL 5 4 1 BAYES-INTERNALS #(NIL NIL NIL) SET-SELECT SELECT LIST) 0 NIL) BAYES-MODEL-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:MODE-VALUES) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :PARAMETER-SCALE #K(#(77 1 2 1 3 3 0 1 2 1 62 5 6 21 0 1 2 2 23 4 0 3 6 4 2 25 5 0 2 6 4) #(0 18 25) #(NIL 2 BAYES-INTERNALS #(NIL) SET-SELECT SELECT) 0 NIL) BAYES-MODEL-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:PARAMETER-SCALE) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :PARAMETER-DIMENSION #K(#(80 2 2 0 1 1 62 3 4 23 2 4 2 4 2 25 3 0 1 4) #(0) #(1 BAYES-INTERNALS SELECT LENGTH) 0 NIL) BAYES-MODEL-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:PARAMETER-DIMENSION) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :DERIVSTEP #K(#(80 2 2 0 1 1 62 3 4 25 2 0 2 4 2) #(0) #(3 BAYES-INTERNALS SELECT) 0 NIL) BAYES-MODEL-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:DERIVSTEP) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :NEEDS-MAXIMIZING #K(#(77 1 2 1 3 3 0 1 2 3 64 2 6 21 2 1 2 2 0 2 7 1 3 0 3 7 62 5 8 21 0 4 5 6 23 4 0 3 8 4 7 25 5 0 2 8 4) #(0 18 23 26 34 41) #(NIL 6 BAYES-INTERNALS #(%NOT-SUPPLIED) SET-SELECT SELECT) 0 NIL) BAYES-MODEL-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:NEEDS-MAXIMIZING) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 2 0 1 1 23 2 3 1 2 25 3 0 2 1 3) #(0) #(FUNCTION-LIST #K(#(77 1 2 1 2 2 0 1 3 23 3 5 1 1 21 0 2 1 5 23 4 5 1 1 21 0 3 4 5 25 5 0 1 1 23 6 5 1 1 21 0 5 8 5 21 0 6 7 2 38 7 5 23 8 5 3 2 5 4 23 5 6 2 2 2 38 7 7 23 8 6 3 6 7 4 6 5 1 3 0 51 9 5 3 6 5 1 25 5 0 1 5 51 10 5 1 1 25 5 0 1 5 51 11 5 1 2 25 9 0 2 5 1 80 5 0 1 9 4 3 5 25 5 0 3 5 2 1 80 3 0 0 9 2 1 0 57 0 80 3 0 1 23 10 3 2 2 1 16 3 0 57 0) #(0 19 24 29 34 44 49 92 102 113 128 138) #(1 0 #(NIL) FUNCTIONP OBJECTP LIST INTEGERP :INITIAL-ELEMENT MAKE-ARRAY MAPCAR FUNCTION-LIST) 0 NIL) BYTE-CODE-CLOSE XLISP::INSTALL-FUNCTION) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :MODE #K(#(80 2 1 0 2 38 1 3 23 2 3 2 1 3 21 0 1 2 3 38 3 4 23 2 0 2 1 4 38 4 3 23 2 3 2 1 3 16 3 0 57 0) #(0 19 28) #(NIL :NEEDS-MAXIMIZING SEND :MAXIMIZE :MODE-VALUES) 0 NIL) BAYES-MODEL-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:MODE) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :NEW-MODE-GUESS #K(#(80 3 1 0 1 38 1 4 23 2 0 3 1 4 3 38 3 4 25 2 0 3 1 4 2) #(0) #(T :NEEDS-MAXIMIZING SEND :MODE-VALUES) 0 NIL) BAYES-MODEL-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:NEW-MODE-GUESS) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :TRANSFORMED-LOGPOST #K(#(80 2 2 0 1 8 38 2 4 23 3 4 2 1 4 21 0 1 2 4 38 4 5 23 3 0 2 1 5 38 5 4 23 3 4 2 1 4 16 4 5 71 2 2 4 6 71 3 4 4 7 38 6 8 23 3 8 2 1 8 38 7 9 23 3 9 2 1 9 38 8 10 38 9 11 25 3 0 8 10 11 9 5 7 6 3 8) #(0 20 29) #(NIL 1 :NEEDS-MAXIMIZING SEND :MAXIMIZE :MODE-VALUES :DERIVSTEP :LOGPOST SCALED-LOGPOST-PROTO :NEW) 0 NIL) BAYES-MODEL-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:TRANSFORMED-LOGPOST) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :TRANSFORMED-FUNCTIONS #K(#(77 1 2 3 1 1 0 8 38 2 6 23 3 6 2 1 6 21 0 1 2 6 38 4 7 23 3 0 2 1 7 38 5 6 23 3 6 2 1 6 16 6 7 71 3 4 6 8 38 6 9 23 3 9 2 1 9 23 7 10 1 7 21 0 3 4 2 0 2 11 1 5 23 8 11 1 10 23 9 10 2 11 10 23 10 11 1 3 21 0 6 7 11 23 7 12 1 10 23 11 11 2 3 12 1 8 0 3 11 23 10 12 1 4 21 0 9 10 12 23 7 13 1 10 23 11 12 2 4 13 1 11 0 4 12 51 12 13 3 9 8 7 25 12 0 4 13 10 11 12 80 7 0 2 38 13 7 38 14 8 25 3 0 8 7 8 4 3 2 5 6 1) #(0 22 31 67 72 77 93 106 109 119 132 135 150) #(NIL #(NIL 0 1) :NEEDS-MAXIMIZING SEND :MAXIMIZE :MODE-VALUES :DERIVSTEP LENGTH ISEQ FUNCTION-LIST NUMBERP REPEAT MAPCAR SCALED-C2-FUNCTION-PROTO :NEW) 0 NIL) BAYES-MODEL-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:TRANSFORMED-FUNCTIONS) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :MAXIMIZE #K(#(77 1 2 1 2 2 0 1 8 38 3 5 23 4 5 2 1 5 38 5 6 23 4 6 2 1 6 16 6 6 38 6 7 23 4 7 2 1 7 38 7 8 23 4 8 2 1 8 38 8 9 38 7 10 38 9 11 38 10 12 23 11 5 10 5 6 9 7 10 8 11 2 12 4 16 5 6 71 2 2 5 7 23 12 8 1 5 61 45 8 8 23 13 8 1 8 23 14 8 1 8 16 8 8 38 5 9 23 4 0 5 1 9 6 7 8 38 15 5 23 4 0 3 1 5 3 38 16 5 25 4 0 3 1 5 2) #(0) #(NIL T #(0) :LOGPOST SEND :MODE-VALUES :PARAMETER-SCALE :DERIVSTEP :SCALE :VERBOSE :RETURN-DERIVS NEWTONMAX FOURTH INVERSE CHOL-DECOMP :NEEDS-MAXIMIZING :CHECK-DERIVATIVES) 0 NIL) BAYES-MODEL-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:MAXIMIZE) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :CHECK-DERIVATIVES #K(#(77 1 2 2 5 5 0 1 2 3 4 10 23 6 9 1 2 21 0 1 2 9 3 60 8 2 9 1 3 0 2 9 38 7 10 23 8 10 2 1 10 38 9 11 23 8 11 2 1 11 38 10 12 23 11 13 2 8 10 23 8 11 3 11 12 13 38 12 12 23 8 12 2 1 12 23 13 13 1 10 2 43 11 13 13 23 14 13 1 13 23 15 13 1 13 37 62 4 13 13 3 21 0 5 6 9 23 16 0 2 6 4 23 17 13 1 11 61 45 13 13 23 18 13 1 13 16 13 13 38 19 14 23 8 14 2 1 14 71 3 4 14 15 23 20 15 2 15 13 38 19 16 16 14 17 71 2 2 14 18 23 8 0 5 1 16 17 18 15 21 0 8 7 12 38 12 13 23 8 0 3 1 13 7 21 0 9 12 9 38 9 11 23 8 11 2 1 11 38 10 12 23 11 13 2 8 10 23 8 11 3 11 12 13 23 13 12 1 10 2 43 11 12 9 23 14 9 1 9 23 15 9 1 9 37 62 10 11 9 3 25 16 0 2 6 5 11 0 7 11 0 7 11 0 7) #(0 22 29 32 101 106 112 174 184 189 240 246 249 252) #("Adjusting derivatives...~%" "Derivatives may not be well-behaved.~%" T NIL 0 #(0 1.0E-5) NUMBERP :PARAMETER-DIMENSION SEND :TRANSFORMED-LOGPOST :HESSIAN REPEAT :NEEDS-MAXIMIZING IDENTITY-MATRIX ABS MAX FORMAT INVERSE CHOL-DECOMP :MODE-VALUES MATMULT) 0 NIL) BAYES-MODEL-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:CHECK-DERIVATIVES) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Args: (&optional gfuns &key covar) 
Computes first order approximations to posterior moments. GFUNS can be
a parameter index, list of indices, a function of the parameters or a
list of such functions. Returns a the list of first order approximate
means and standard deviations if COVAR is NIL. If COVAR is T the
covaraince is appended to the end of the result as well." :1STMOMENTS #K(#(77 3 2 1 5 0 0 4 3 3 0 1 2 6 38 6 7 23 7 7 2 1 7 21 0 1 2 7 38 8 8 23 7 0 2 1 8 38 9 7 23 7 7 2 1 7 23 10 7 2 6 7 38 11 8 23 7 8 5 1 8 2 6 5 39 12 9 51 6 10 1 7 23 13 10 2 10 8 23 14 9 2 9 10 51 5 10 1 7 23 13 10 2 10 8 23 15 11 1 9 23 16 11 2 11 9 21 0 3 4 3 23 17 12 1 11 23 18 12 1 12 25 19 0 3 10 12 11 23 17 11 1 11 23 18 11 1 11 25 19 0 2 10 11 80 3 0 1 38 20 3 25 7 0 3 2 3 1 80 3 0 1 38 21 3 25 7 0 3 2 3 1) #(0 28 37 111 128 144 158) #(NIL 1 0 (NIL) (:COVAR) #(NIL) :NEEDS-MAXIMIZING SEND :MAXIMIZE :PARAMETER-DIMENSION REPEAT :TRANSFORMED-FUNCTIONS BIND-COLUMNS MAPCAR APPLY TRANSPOSE MATMULT DIAGONAL SQRT LIST :VALUE :GRADIENT) 0 NIL) BAYES-MODEL-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:1STMOMENTS) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :MGFMOMENTS #K(#(77 3 2 1 7 0 0 6 5 5 0 1 2 3 4 25 38 8 12 38 9 13 23 10 12 5 1 12 2 13 3 16 12 13 71 2 2 12 14 21 0 1 2 3 71 3 4 12 15 1 3 0 11 15 38 11 16 23 10 16 2 1 16 38 12 17 23 10 17 5 1 17 2 13 14 38 13 18 23 10 18 6 16 18 11 6 10 5 51 10 19 5 4 16 6 5 18 23 14 19 4 19 13 14 17 23 15 19 1 19 21 0 4 9 3 71 2 2 19 20 23 16 21 2 20 9 23 17 21 1 21 23 16 22 2 14 9 23 16 23 2 20 9 2 45 23 22 24 2 47 24 23 22 23 16 23 2 4 9 2 42 9 23 23 61 45 4 24 23 18 25 1 17 0 8 26 37 60 5 8 26 25 0 26 27 0 8 28 37 60 6 7 28 27 23 19 29 2 26 28 23 20 29 2 17 29 23 20 30 2 22 26 23 20 31 2 22 28 23 20 32 2 20 26 23 20 33 2 20 28 27 11 34 6 18 5 6 16 29 4 27 11 35 6 18 5 6 16 29 24 2 43 34 35 34 2 47 34 23 34 2 42 7 30 35 2 42 7 31 36 23 21 34 3 34 35 36 68 15 26 28 35 23 22 36 3 34 32 33 2 43 35 36 29 67 21 26 28 29 0 67 21 28 26 29 0 61 112 28 28 37 60 6 7 28 27 61 112 26 26 37 60 5 8 26 25 23 19 27 1 21 25 23 0 2 19 27 11 0 19 80 9 2 24 2 5 27 11 11 6 5 4 3 2 8 1 61 45 1 12 27 11 12 6 5 4 3 2 8 12 2 45 11 12 13 2 42 10 1 14 2 47 13 14 13 2 42 7 13 13 2 43 6 13 13 2 43 11 12 14 23 16 15 2 1 10 2 47 14 15 14 2 43 9 14 14 23 25 14 1 14 2 42 7 14 14 25 19 0 2 13 14 80 7 1 3 1 38 26 8 23 10 8 8 4 8 5 6 7 3 7 2 2 45 8 1 0 57 0) #(0 44 51 54 115 182 194 316 326 337 340 432) #(0.5 0 2 T NIL (NIL 0.1 0.1 2) (:COVAR :MGFDEL :DERIVSTEP :MAXITER) #(NIL) :1STMOMENTS :COVAR SEND :TRANSFORMED-LOGPOST :TRANSFORMED-FUNCTIONS :LOG-LAPLACE MAPCAR TRANSPOSE ^ DIAGONAL LENGTH LIST SELECT - * APPEND 1 SQRT :TILT-LAPLACE) 0 NIL) BAYES-MODEL-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:MGFMOMENTS) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :FULLMOMENTS #K(#(77 3 2 1 6 0 0 5 4 4 0 1 2 3 17 38 7 10 23 8 10 3 1 10 2 16 10 10 38 9 11 23 8 11 2 1 11 38 10 12 23 8 12 5 1 12 2 9 10 38 11 13 23 8 13 6 11 13 8 5 8 4 51 7 14 4 11 5 4 13 23 12 14 3 14 12 10 23 13 14 1 14 21 0 1 6 3 16 14 15 2 47 15 10 15 71 2 2 14 16 23 14 16 2 16 7 23 15 16 1 16 23 16 17 1 12 0 9 18 37 60 2 5 18 17 0 18 19 0 9 20 37 60 3 4 20 19 23 17 21 2 18 20 23 18 21 2 12 21 27 8 21 6 13 4 5 11 21 6 23 19 21 1 21 23 18 22 2 15 18 23 18 23 2 15 20 23 18 24 2 10 18 23 18 25 2 10 20 2 42 22 23 26 2 45 21 26 26 23 20 21 3 26 24 25 67 16 18 20 21 0 67 16 20 18 21 0 61 112 20 20 37 60 3 4 20 19 61 112 18 18 37 60 2 5 18 17 23 17 19 1 16 25 21 0 2 14 19 11 0 14 80 7 3 1 22 0 3 27 8 10 6 4 3 2 1 5 9 23 19 10 1 10 27 8 11 6 4 3 2 1 5 8 23 19 11 1 11 23 14 12 2 10 7 2 45 11 12 11 23 23 11 1 11 23 17 10 2 10 11 2 42 6 10 0 57 0 80 7 1 2 1 38 24 8 23 8 8 8 4 8 5 6 7 3 7 2 2 45 8 1 0 57 0) #(0 87 125 137 227 237 248 251 317) #(1.0 2 NIL 0 (NIL 0.1 2) (:COVAR :DERIVSTEP :MAXITER) #(NIL) :1STMOMENTS SEND :TRANSFORMED-LOGPOST :TRANSFORMED-FUNCTIONS :LOG-LAPLACE MAPCAR TRANSPOSE ^ DIAGONAL LENGTH LIST SELECT EXP * APPEND 2.0 SQRT :TILT-LAPLACE) 0 NIL) BAYES-MODEL-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:FULLMOMENTS) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :2NDMOMENTS #K(#(77 2 2 0 0 2 39 0 3 38 1 4 25 2 0 4 3 1 4 2) #(0) #(SEND :MGFMOMENTS APPLY) 0 NIL) BAYES-MODEL-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:2NDMOMENTS) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Args: (&optional gfuns &key covar) 
Computes second order approximations to posterior moments. GFUNS can be
a parameter index, list of indices, a function of the parameters or a
list of such functions. Returns a the list of second order approximate
means and standard deviations if COVAR is NIL. If COVAR is T the
covaraince is appended to the end of the result as well." :MOMENTS #K(#(77 2 2 0 0 2 39 0 3 38 1 4 25 2 0 4 3 1 4 2) #(0) #(SEND :2NDMOMENTS APPLY) 0 NIL) BAYES-MODEL-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:MOMENTS) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 3 0 1 2 4 39 3 4 23 4 5 1 3 21 0 1 2 5 0 3 5 1 3 23 5 5 1 3 23 6 4 2 4 5 0 3 5 16 5 6 21 1 4 5 5 38 7 7 23 8 0 3 4 7 6 17 5 5 16 5 6 21 1 4 5 5 38 9 7 23 8 0 4 4 7 2 1 23 10 0 2 2 4 11 0 2) #(0 20 25 30 47 68) #((LOGPOST G X VAL I J A GRAD GVAL LU H) LAPLACE-MARGIN-PROTO NIL MAKE-OBJECT LISTP LIST APPLY :ADD-SLOT SEND :MAKE-PROTOTYPE SET) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :ISNEW #K(#(80 7 9 0 1 2 3 4 5 6 7 8 2 63 15 2 0 63 14 3 0 2 43 4 5 16 23 9 16 2 13 16 63 12 16 0 23 10 16 1 4 63 11 16 0 23 10 16 1 5 2 43 4 16 16 63 10 16 0 2 43 4 5 16 2 43 4 5 17 23 11 16 2 16 17 38 12 17 23 13 16 3 16 17 13 63 9 16 0 63 8 6 0 38 14 16 25 15 0 3 1 16 7) #(0) #(T H A J I X 0 G LOGPOST REPEAT ISEQ LIST :INITIAL-ELEMENT MAKE-ARRAY :ADJUST-INTERNALS SEND) 0 NIL) LAPLACE-MARGIN-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:ISNEW) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :ADJUST-INTERNALS #K(#(77 1 2 1 12 12 0 1 2 3 4 5 6 7 8 9 10 11 20 62 14 15 62 13 16 62 12 17 62 11 18 62 10 19 62 9 20 62 8 21 23 13 22 2 19 17 23 13 23 2 19 18 23 14 24 1 22 21 0 1 2 2 23 15 25 2 3 24 23 16 26 1 24 61 45 26 26 23 17 24 3 3 25 26 1 3 38 18 25 23 19 24 4 15 25 22 21 16 24 25 71 2 2 24 26 71 3 4 24 27 51 4 28 2 21 22 23 20 28 2 28 16 39 21 29 23 20 29 2 29 28 39 22 30 23 20 30 2 30 28 39 23 31 23 20 31 2 31 28 39 24 32 23 25 32 2 32 30 63 7 25 0 39 26 33 2 42 23 30 34 23 25 33 3 33 26 34 63 6 33 0 63 5 29 0 39 26 33 2 42 23 31 34 23 25 33 3 33 27 34 23 27 0 4 20 17 17 33 23 27 0 4 20 17 18 32 23 28 21 1 32 23 27 0 4 20 18 17 21 23 29 15 1 20 63 4 15 0 57 0 80 4 0 1 38 18 4 25 19 0 4 3 4 2 1) #(0 62 86 97 240) #(0 LU GVAL GRAD VAL H A X J I G LOGPOST #(NIL) SELECT LENGTH REPEAT IDENTITY-MATRIX LIST :VALS SEND MAPCAR FIRST SECOND THIRD BIND-COLUMNS APPLY + SET-SELECT TRANSPOSE LU-DECOMP) 0 NIL) LAPLACE-MARGIN-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:ADJUST-INTERNALS) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :MOVE-TO #K(#(80 3 4 0 1 2 3 5 62 6 7 62 5 8 62 4 9 62 3 10 2 45 9 2 11 23 4 11 2 8 11 23 5 8 2 10 11 2 45 7 8 7 63 6 7 0 38 6 7 25 7 0 2 1 7) #(0) #(LU GVAL GRAD X COMBINE LU-SOLVE :ADJUST-INTERNALS SEND) 0 NIL) LAPLACE-MARGIN-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:MOVE-TO) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :LOG-DENSITY #K(#(77 1 2 1 4 4 0 1 2 3 3 62 6 7 21 0 1 2 2 11 0 7 62 5 8 23 5 9 1 8 21 0 3 4 9 11 0 3 16 8 8 23 6 8 1 8 23 7 8 1 8 23 8 8 1 8 23 9 8 1 8 2 42 4 8 8 2 43 8 7 0 57 0) #(0 19 22 35 38) #(NIL -0.5 LU VAL #(NIL) FOURTH DIAGONAL ABS LOG SUM) 0 NIL) LAPLACE-MARGIN-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:LOG-DENSITY) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :LOG-MARGIN1 #K(#(77 3 4 0 0 0 5 4 4 0 1 2 3 16 38 6 11 23 7 11 3 1 11 2 16 11 12 23 8 12 2 12 10 71 2 2 11 13 23 8 13 2 13 10 38 9 14 23 7 14 2 1 14 38 10 15 23 7 15 2 1 15 38 11 16 23 7 16 5 1 16 2 12 13 2 45 3 12 17 2 47 17 13 17 3 76 17 10 18 23 12 18 1 18 23 8 18 2 17 18 23 13 18 1 18 23 14 18 2 18 9 3 62 17 10 19 23 12 19 1 19 23 8 19 2 17 19 23 13 19 1 19 23 14 19 2 19 9 23 15 20 1 18 27 5 20 6 6 4 14 16 15 20 23 15 20 1 20 27 5 21 6 6 4 14 16 15 19 23 16 22 2 18 19 23 16 23 2 20 21 39 17 24 23 18 24 2 24 23 23 12 24 1 24 23 8 25 2 22 24 23 8 26 2 23 24 21 0 1 2 5 23 19 14 2 25 26 1 3 23 2 14 2 25 26 16 14 15 2 42 13 15 15 2 43 12 15 15 71 2 2 14 16 23 20 17 1 13 38 21 18 2 42 8 18 18 23 20 18 1 18 2 42 7 18 18 23 22 16 3 16 17 18 25 2 0 2 15 16 80 4 0 1 38 23 4 23 7 0 3 2 4 3 38 24 4 25 7 0 3 2 4 1 80 7 1 25 2 38 26 8 38 27 9 23 7 8 7 8 9 5 4 3 7 2 51 4 8 2 1 8 25 18 0 2 8 6) #(0 211 219 225 279 303) #(0.5 2 LIST 0 (0.05 T NIL) (:DERIVSTEP :SPLINE :PROFILE) :1STMOMENTS SEND SELECT :PARAMETER-DIMENSION :TRANSFORMED-LOGPOST :TRANSFORMED-FUNCTIONS WHICH SORT-DATA COERCE REVERSE APPEND NUMBERP MAPCAR SPLINE LOG PI - :MOVE-TO :LOG-DENSITY 1 LAPLACE-MARGIN-PROTO :NEW) 0 NIL) BAYES-MODEL-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:LOG-MARGIN1) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #("Args: (g x &key (:derivstep .05) (spline t) profile)
Computes Laplace approximation to marginal posterior density of G at
points X. G can be an index or a function of the parameter vector. X
is a sequence that should include the modal value of G. If SPLINE is
true the log density is splined. If PROFILE is true, a profile of the
posterior is returned." :MARGIN1 #K(#(77 3 4 0 0 0 1 0 0 4 38 2 7 38 3 8 38 4 9 38 5 10 23 6 7 10 1 7 2 3 8 4 9 5 10 6 16 7 8 71 2 2 7 9 23 7 9 1 9 25 8 0 2 8 9) #(0) #((0.05 T NIL) (:DERIVSTEP :SPLINE :PROFILE) :LOG-MARGIN1 :DERIVSTEP :SPLINE :PROFILE SEND EXP LIST) 0 NIL) BAYES-MODEL-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:MARGIN1) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :IMPSAMPLE #K(#(77 3 2 1 3 0 0 2 1 1 0 8 38 4 6 23 5 6 2 1 6 38 6 7 23 5 7 3 1 7 2 38 7 8 23 5 8 2 1 8 23 8 9 2 3 4 23 9 10 2 8 3 23 10 10 1 10 2 47 4 9 11 23 11 11 1 11 2 42 10 11 9 2 43 8 4 10 2 47 10 5 10 23 12 10 1 10 2 47 4 5 11 23 12 11 1 11 2 47 8 5 12 2 47 4 5 13 23 13 13 1 13 2 42 12 13 12 23 14 10 3 10 11 12 51 5 11 1 7 23 15 11 2 11 9 51 1 12 4 10 4 8 6 23 15 12 2 12 9 25 16 0 2 11 12 80 6 3 17 18 19 3 38 20 9 23 5 9 3 4 9 5 2 43 3 2 10 2 42 5 5 11 23 21 11 1 11 2 47 11 2 11 2 43 8 11 11 23 13 11 1 11 23 22 10 3 7 10 11 23 23 11 1 9 21 0 2 3 11 23 14 9 3 9 10 1 25 24 0 1 9 11 0 6 80 3 0 1 38 20 3 25 5 0 3 2 3 1 80 3 0 1 51 4 3 1 2 25 15 0 2 3 1) #(0 155 219 231 234 248) #(2 (100 2) (:N :DF) #(NIL) :TRANSFORMED-LOGPOST SEND :TRANSFORMED-FUNCTIONS :PARAMETER-DIMENSION CHISQ-RAND REPEAT NORMAL-RAND SQRT LOG-GAMMA LOG - MAPCAR LIST 0 -0.5 1 :VALUE SUM * REALP EXP) 0 NIL) BAYES-MODEL-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:IMPSAMPLE) 0 NIL)) EVAL) 0 NIL)
#K(#(80 1 1 0 0 25 1 0 1 1) #(0) #((PROGN #K(#(80 1 3 0 1 2 2 38 3 4 23 4 5 1 3 25 5 0 4 4 2 5 1) #(0) #(NIL :IMPMOMENTS #K(#(77 3 2 1 2 0 0 1 0 0 5 38 3 5 38 4 6 38 5 7 23 6 5 7 1 5 2 6 3 7 4 39 7 6 16 5 7 71 2 2 5 8 2 42 7 8 7 23 8 6 2 6 7 39 7 7 71 2 2 5 8 23 8 7 2 7 8 2 47 6 7 6 16 5 7 51 1 8 1 6 23 9 7 2 8 7 39 7 8 71 2 2 5 9 2 42 7 9 9 23 8 7 2 8 9 39 7 8 71 2 2 5 9 23 8 8 2 8 9 2 47 7 8 7 23 10 7 1 7 25 11 0 2 6 7 80 3 1 12 1 2 45 2 1 4 25 13 0 2 4 3) #(0 135) #((100 2) (:N :DF) #(NIL) :IMPSAMPLE :N :DF SEND + REDUCE MAPCAR SQRT LIST 2 ^) 0 NIL) BAYES-MODEL-PROTO BYTE-CODE-CLOSE XLISP::ADD-METHOD) 0 NIL) #K(#(80 1 1 0 0 11 0 1) #(0) #(:IMPMOMENTS) 0 NIL)) EVAL) 0 NIL)
