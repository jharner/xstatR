(provide ":StatIns:discdistn.lsp")
(require ":StatIns:symbols.lsp")
(require ":StatIns:distns.lsp")

;;
;; Discrete distribution proto
;;

(defproto disc-distn-proto '() '() distn-proto)

(defmeth disc-distn-proto :isnew (pdf cdf quant wind)
  (call-next-method pdf nil cdf quant wind))

(defmeth disc-distn-proto :leq-prob (x)
  (funcall (send self :cdf) (floor x)))

(defmeth disc-distn-proto :l-prob (x)
  (funcall (send self :cdf) (- (floor x) 1)))

(defmeth disc-distn-proto :geq-prob (x)
  (- 1 (funcall (send self :cdf) (- (floor x) 1))))

(defmeth disc-distn-proto :g-prob (x)
  (- 1 (funcall (send self :cdf) (ceiling x))))

(defmeth disc-distn-proto :eq-prob (x)
  (funcall (send self :pdf) (ceiling x)))

(defmeth disc-distn-proto :add-cdf (adjust)
  (let* ((lb (floor (send self :lb)))
         (ub (ceiling (send self :ub)))
         (cdf (send self :cdf))
         (x (iseq lb ub))
         (nr (get-nice-range lb (+ ub 1) (- ub lb)))
         (w (send self :wind))
         (cr (send w :content-rect))
         (cx1 (select cr 0))
         (cy1 (select cr 1))
         (cx2 (select cr 2))
         (cy2 (select cr 3)))
    (dolist (i x prob)
            (setf prob (funcall cdf i))
            (send w :add-lines (list (list i (+ i 1)) (list prob prob)) :color 'BLUE :draw nil))
    (cond (adjust
           (send w :range 0 (select nr 0) (select nr 1) :draw nil)
           (send w :x-axis t t (select nr 2) :draw nil)
           (send w :range 1 0 1 :draw nil)
           (send w :y-axis t t 5)))))

(defmeth disc-distn-proto :add-pdf (adjust)
  (let* ((lb (floor (send self :lb)))
         (ub (ceiling (send self :ub)))
         (pdf (send self :pdf))
         (x (iseq lb ub))
         (y-upper (max (funcall pdf (iseq lb ub))))
         (y-lower 0)
         (nry (get-nice-range y-lower y-upper 5))
         (x1 (send self :x1))
         (x2 (send self :x2))
         (ineq (send self :ineq))
         (nr (get-nice-range lb ub (- ub lb)))
         (w (send self :wind))
         (j 0)
         (cr (send w :content-rect))
         (cx1 (select cr 0))
         (cy1 (select cr 1))
         (cx2 (select cr 2))
         (cy2 (select cr 3))
         (px (cond 
              ((= ineq 0)
               (iseq (floor x1) (floor x1)))
              ((= ineq 1)
               (iseq 0 (floor x1)))
              ((= ineq 2)
               (iseq 0 (- (floor x1) 1)))
              ((= ineq 3)
               (iseq (ceiling x1) ub))
              ((= ineq 4)
               (iseq (+ (ceiling x1) 1) ub))
              ((= ineq 5)
               (iseq (ceiling x1) (floor x2)))
              ((= ineq 6)
               (iseq (+ (ceiling x1) 1) (floor x2)))
              ((= ineq 7)
               (iseq (ceiling x1) (- (floor x2) 1)))
              ((= ineq 8)
               (iseq (+ (ceiling x1) 1) (- (floor x2) 1)))
              ((= ineq 9)
               (sort-data (append (iseq 0 (floor x1)) (iseq (ceiling x2) ub))))
              ((= ineq 10)
               (sort-data (append (iseq 0 (- (floor x1) 1)) (iseq (ceiling x2) ub))))
              ((= ineq 11)
               (sort-data (append (iseq 0 (floor x1)) (iseq (+ (ceiling x2) 1) ub))))
              ((= ineq 12)
               (sort-data (append (iseq 0 (- (floor x1) 1)) (iseq (+ (ceiling x2) 1) ub)))))))
    (dolist (i x prob)
            (setf prob (funcall pdf i))
            (if (member i px)
                (send w :add-lines (list (list i i) (list 0 prob)) :color 'RED :draw nil)
                (send w :add-lines (list (list i i) (list 0 prob)) :color 'BLUE :draw nil))
            (setf j (+ j 1)))
    (cond (adjust
           (send w :range 0 (select nr 0) (select nr 1) :draw nil)
           (send w :range 1 (select nry 0) (select nry 1) :draw nil)
           (send w :x-axis t t (select nr 2) :draw nil)
           (send w :y-axis t t 5)))))

;;
;; Binomial distribution
;;

(defproto binomial-distn-proto '(n p) '() disc-distn-proto)

(defmeth binomial-distn-proto :isnew (n p wind)
  (let* ((pdf (lambda (x)
                (let* ((n (ceiling (select (send self :param-values) 0)))
                       (p (select (send self :param-values) 1)))
                  (funcall #'binomial-pmf x n p))))
          (cdf (lambda (x)
                (let* ((n (ceiling (select (send self :param-values) 0)))
                       (p (select (send self :param-values) 1)))
                  (funcall #'binomial-cdf x n p))))
         (quant (lambda (q)
                  (let* ((n (ceiling (select (send self :param-values) 0)))
                         (p (select (send self :param-values) 1)))
                  (funcall #'binomial-quant q n p)))))
    (send self :name "Binomial")
    (send self :param-values (list n p .5 5))
    (send self :param-incrs (list 1 .05 .05 1))
    (send self :param-symbols (list np pp qp np))
    (send self :param-names (list "n" "p" "q" "sample size"))
    (send self :lb 0)
    (send self :ub n)
    (call-next-method pdf cdf quant wind)))

(defmeth binomial-distn-proto :check-params ()
  (let* ((params (send self :param-values))
         (incrs (send self :param-incrs))
         (n (select params 0))
         (p (select params 1))
         (n-incr (select incrs 0))
         (p-incr (select incrs 1)))
    (cond ((< n 1)
           (setf (select (send self :param-values) 0) 1)))
    (cond ((< p 0)
           (setf (select (send self :param-values) 1) 0)))
    (cond ((> p 1)
           (setf (select (send self :param-values) 1) 1)))
    (setf (select (send self :param-incrs) 0) (ceiling n-incr))
    (call-next-method)))
    

(defmeth binomial-distn-proto :add-pdf (adjust)
  (let* ((dumb (send self :check-params))
         (w (send self :wind))
         (params (send self :param-values))
         (n (select params 0))
         (p (select params 1))
         (pdf (send self :pdf))
         (y-range (send w :range 1))
         (ylb (select y-range 0))
         (yub (select y-range 1))
         (x-range (send w :range 0))
         (xlb (select x-range 0))
         (xub (select x-range 1)))
    (send self :ub (select (send self :param-values) 0))
    (cond (adjust
           (send w :range 1 0 (funcall pdf (ceiling (* n p))) :draw nil)))
    (call-next-method adjust)))

(defmeth binomial-distn-proto :add-cdf (adjust)
  (let* ((dumb (send self :check-params))
         (w (send self :wind))
         (params (send self :param-values))
         (n (select params 0))
         (p (select params 1))
         (pdf (send self :pdf))
         (y-range (send w :range 1))
         (ylb (select y-range 0))
         (yub (select y-range 1))
         (x-range (send w :range 0))
         (xlb (select x-range 0))
         (xub (select x-range 1)))
    (send self :ub (select (send self :param-values) 0))
    (cond (adjust
           (send w :range 1 0 (funcall pdf (ceiling (* n p))) :draw nil)))
    (call-next-method adjust)))

;;
;; Poisson distribution
;;

(defproto poisson-distn-proto '(l) '() disc-distn-proto)

(defmeth poisson-distn-proto :isnew (l wind)
  (let* ((pdf (lambda (x)
                (let* ((l (select (send self :param-values) 0)))
                  (funcall #'poisson-pmf x l))))
          (cdf (lambda (x)
                (let* ((l (select (send self :param-values) 0)))
                  (funcall #'poisson-cdf x l))))
         (quant (lambda (q)
                  (let* ((l (select (send self :param-values) 0)))
                  (funcall #'poisson-quant q l)))))
    (send self :name "Poisson")
    (send self :param-values (list l nil .5 5))
    (send self :param-incrs (list .1 nil .05 1))
    (send self :param-symbols (list lambdap nil qp np))
    (send self :param-names (list "lambda" nil "q" "sample size"))
    (send self :lb 0)
    (send self :ub (funcall quant .9999))
    (call-next-method pdf cdf quant wind)))

(defmeth poisson-distn-proto :add-cdf (adjust)
  (send self :ub (funcall (send self :quant) .9999))
  (call-next-method adjust))

(defmeth poisson-distn-proto :add-pdf (adjust)
 (let* ((w (send self :wind))
        (quant (send self :quant))
        (lb (funcall quant .001))
        (ub (funcall quant .999))
        (pdf (send self :pdf))
        (med (funcall quant .5))
        (params (send self :param-values))
        (l (select params 0))
        (pdf (send self :pdf))
        (up (funcall pdf (ceiling l)))
        (y-range (send w :range 1))
        (ylb (select y-range 0))
        (yub (select y-range 1))
        (x-range (send w :range 0))
        (xlb (select x-range 0))
        (xub (select x-range 1)))
   (send self :ub (funcall (send self :quant) .9999))
   (cond (adjust
          (send w :range 1 0 up :draw nil)))
   (call-next-method adjust)))
